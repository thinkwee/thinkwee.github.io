<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Noto+Serif+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"thinkwee.top","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"duration":50,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Record the principles and derivations of algorithms used for inferring unknown variables in probabilistic machine learning, such as Variational Inference, Expectation Maximization, and Markov Chain M">
<meta property="og:type" content="article">
<meta property="og:title" content="Note for Inference Algorithms in Probabilistic ML">
<meta property="og:url" content="https://thinkwee.top/2018/08/28/inference-algorithm/index.html">
<meta property="og:site_name" content="Thinkwee&#39;s Blog">
<meta property="og:description" content="Record the principles and derivations of algorithms used for inferring unknown variables in probabilistic machine learning, such as Variational Inference, Expectation Maximization, and Markov Chain M">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.mji.rip/2025/07/16/cbd846ecd88abb611db2c204930d896d.png">
<meta property="og:image" content="https://s1.ax1x.com/2018/10/19/iwWPun.png">
<meta property="og:image" content="https://s1.ax1x.com/2018/10/20/i0oFwd.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2018/10/20/i0oEFI.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2018/10/20/i0okTA.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2018/10/20/i0oVYt.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2018/10/20/i0oZfP.png">
<meta property="og:image" content="https://s1.ax1x.com/2018/10/20/i0ou6S.png">
<meta property="og:image" content="https://s1.ax1x.com/2018/10/20/i0oFwd.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2018/10/20/i0oEFI.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2018/10/20/i0okTA.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2018/10/20/i0oVYt.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2018/10/20/i0oZfP.png">
<meta property="og:image" content="https://s1.ax1x.com/2018/10/20/i0ou6S.png">
<meta property="article:published_time" content="2018-08-28T01:55:10.000Z">
<meta property="article:modified_time" content="2025-07-16T10:40:20.044Z">
<meta property="article:author" content="Thinkwee">
<meta property="article:tag" content="math">
<meta property="article:tag" content="inference">
<meta property="article:tag" content="mcmc">
<meta property="article:tag" content="variational inference">
<meta property="article:tag" content="em">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.mji.rip/2025/07/16/cbd846ecd88abb611db2c204930d896d.png">


<link rel="canonical" href="https://thinkwee.top/2018/08/28/inference-algorithm/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://thinkwee.top/2018/08/28/inference-algorithm/","path":"2018/08/28/inference-algorithm/","title":"Note for Inference Algorithms in Probabilistic ML"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Note for Inference Algorithms in Probabilistic ML | Thinkwee's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-96114782-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-96114782-1","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start --><script>(function() {function calculateHeight(element) {let height = 0;const items = element.children;for (let i = 0; i < items.length; i++) {height += items[i].offsetHeight || 25;const child = items[i].querySelector(".nav-child");if (child && child.style.display !== "none") {height += calculateHeight(child);}}return height;}function generateToc(lang, container) {const content = document.getElementById(lang + "-content");if (!content) return;const headers = Array.from(content.querySelectorAll("h1, h2, h3, h4, h5, h6"));if (headers.length === 0) return;const ol = document.createElement("ol");ol.className = "nav";let currentLevel = 1;let currentOl = ol;let stack = [ol];let counters = [0, 0, 0, 0, 0, 0];headers.forEach((header, index) => {const level = parseInt(header.tagName[1]);counters[level - 1]++;for (let i = level; i < 6; i++) counters[i] = 0;const li = document.createElement("li");li.className = "nav-item nav-level-" + level;if (level === 1 && index === 0) {li.classList.add("active", "active-current");}const link = document.createElement("a");link.className = "nav-link";if (level === 1 && index === 0) link.classList.add("active");link.href = "#" + header.id;const numSpan = document.createElement("span");numSpan.className = "nav-number";numSpan.textContent = counters.slice(0, level).filter(n => n > 0).join(".");const textSpan = document.createElement("span");textSpan.className = "nav-text";textSpan.textContent = header.textContent;link.appendChild(numSpan);link.appendChild(document.createTextNode(" "));link.appendChild(textSpan);li.appendChild(link);if (level > currentLevel) {const newOl = document.createElement("ol");newOl.className = "nav-child";if (currentLevel === 1) {newOl.style.display = "block";stack[currentLevel - 1].lastElementChild.classList.add("active");}stack[currentLevel - 1].lastElementChild.appendChild(newOl);stack[level - 1] = newOl;currentOl = newOl;} else if (level < currentLevel) {currentOl = stack[level - 1];}currentOl.appendChild(li);currentLevel = level;});container.appendChild(ol);setTimeout(() => {const navHeight = calculateHeight(ol);ol.style.setProperty("--height", navHeight + "px");const navChilds = ol.getElementsByClassName("nav-child");Array.from(navChilds).forEach(child => {if (child.style.display === "block") {const childHeight = calculateHeight(child);child.style.setProperty("--height", childHeight + "px");}});}, 0);return ol;}function updateActiveHeading() {const activeLang = document.getElementById("en-content").style.display === "block" ? "en" : "zh";const content = document.getElementById(activeLang + "-content");const toc = document.getElementById(activeLang + "-toc");if (!content || !toc) return;const headers = Array.from(content.querySelectorAll("h1, h2, h3, h4, h5, h6"));const scrollPos = window.scrollY + window.innerHeight / 3;let activeHeader = null;for (let i = headers.length - 1; i >= 0; i--) {const header = headers[i];const headerTop = header.getBoundingClientRect().top + window.scrollY;if (headerTop <= scrollPos) {activeHeader = header;break;}}const links = toc.getElementsByClassName("nav-link");Array.from(links).forEach(link => {link.classList.remove("active");const parentLi = link.parentElement;if (parentLi) {parentLi.classList.remove("active", "active-current");}});if (activeHeader) {const activeLink = toc.querySelector(`a[href="#${activeHeader.id}"]`);if (activeLink) {activeLink.classList.add("active");let parent = activeLink.parentElement;while (parent && parent.classList) {if (parent.classList.contains("nav-item")) {parent.classList.add("active");if (parent.classList.contains("nav-level-1")) {parent.classList.add("active-current");}}parent = parent.parentElement;}}}}function initTippy() {document.querySelectorAll(".refplus-num").forEach((ref) => {if (ref._tippy) {ref._tippy.destroy();}let refid = ref.firstChild.href.replace(location.origin+location.pathname,"");let refel = document.querySelector(refid);if (!refel) return;let refnum = refel.dataset.num;let ref_content = refel.innerText.replace(`[${refnum}]`,"");tippy(ref, {content: ref_content,});});}function initToc() {const originalToc = document.querySelector(".post-toc-wrap");if (!originalToc || !document.getElementById("langToggle")) return;const tocContainer = document.createElement("div");tocContainer.className = "post-toc-wrap sidebar-panel sidebar-panel-active";const enToc = document.createElement("div");enToc.id = "en-toc";enToc.className = "post-toc motion-element";enToc.style.display = "block";const zhToc = document.createElement("div");zhToc.id = "zh-toc";zhToc.className = "post-toc motion-element";zhToc.style.display = "none";generateToc("en", enToc);generateToc("zh", zhToc);tocContainer.appendChild(enToc);tocContainer.appendChild(zhToc);originalToc.parentNode.replaceChild(tocContainer, originalToc);window.addEventListener("scroll", updateActiveHeading);setTimeout(updateActiveHeading, 0);}window.toggleLanguage = function() {const enContent = document.getElementById("en-content");const zhContent = document.getElementById("zh-content");const enToc = document.getElementById("en-toc");const zhToc = document.getElementById("zh-toc");const button = document.getElementById("langToggle");if (!enContent || !zhContent || !enToc || !zhToc || !button) return;const isEnglish = enContent.style.display === "block";enContent.style.display = isEnglish ? "none" : "block";zhContent.style.display = isEnglish ? "block" : "none";enToc.style.display = isEnglish ? "none" : "block";zhToc.style.display = isEnglish ? "block" : "none";button.querySelector(".button-text").textContent = isEnglish ? "Switch to English" : "切换中文";setTimeout(updateActiveHeading, 0);setTimeout(initTippy, 100);};document.addEventListener("DOMContentLoaded", function() {initToc();setTimeout(initTippy, 3000);});})();</script><style>.post-toc { transition: all 0.2s ease-in-out; }.post-toc .nav { padding-left: 0; }.post-toc .nav-child { padding-left: 1em; }.post-toc .nav-item { line-height: 1.8; }.post-toc .nav-link { color: #555; }.post-toc .nav-link:hover { color: #222; }.post-toc .nav-link.active { color: #fc6423; }.post-toc .active > .nav-link { color: #fc6423; }.post-toc .active-current > .nav-link { color: #fc6423; }</style><!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Thinkwee's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Too Stupid to Give Up Learning</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">51</span></a></li><li class="menu-item menu-item-multi-agent-ebook"><a href="/multiagent_ebook/" rel="section"><i class="fa fa-book fa-fw"></i>Multi-Agent EBook</a></li><li class="menu-item menu-item-iagents"><a href="/iagents/" rel="section"><i class="fa fa-robot fa-fw"></i>iAgents</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Bayesian-Inference"><span class="nav-number">1.</span> <span class="nav-text">Bayesian Inference</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Markov-Chain-Monte-Carlo"><span class="nav-number">2.</span> <span class="nav-text">Markov Chain Monte Carlo</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Sampling"><span class="nav-number">2.1.</span> <span class="nav-text">Sampling</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Refuse-Sampling"><span class="nav-number">2.2.</span> <span class="nav-text">Refuse Sampling</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Adaptive-Rejection-Sampling"><span class="nav-number">2.3.</span> <span class="nav-text">Adaptive Rejection Sampling</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Importance-Sampling"><span class="nav-number">2.4.</span> <span class="nav-text">Importance Sampling</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Markov-Monte-Carlo-and-Metropolis-Hastings-algorithms"><span class="nav-number">2.5.</span> <span class="nav-text">Markov Monte Carlo and Metropolis-Hastings algorithms</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hybrid-Metropolis-Hasting"><span class="nav-number">2.6.</span> <span class="nav-text">Hybrid Metropolis-Hasting</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Gibbs-Sampling"><span class="nav-number">2.7.</span> <span class="nav-text">Gibbs Sampling</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Expectation-Maximization"><span class="nav-number">3.</span> <span class="nav-text">Expectation Maximization</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Update"><span class="nav-number">3.1.</span> <span class="nav-text">Update</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Formula"><span class="nav-number">3.2.</span> <span class="nav-text">Formula</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Why-Effective"><span class="nav-number">3.3.</span> <span class="nav-text">Why Effective</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Understanding-from-the-perspective-of-the-Evidence-Lower-Bound-ELBO"><span class="nav-number">3.4.</span> <span class="nav-text">Understanding from the perspective of the Evidence Lower Bound (ELBO)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#From-the-perspective-of-assuming-latent-variables-to-be-observable"><span class="nav-number">3.5.</span> <span class="nav-text">From the perspective of assuming latent variables to be observable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#From-the-perspective-of-missing-values-in-the-latent-variables"><span class="nav-number">3.6.</span> <span class="nav-text">From the perspective of missing values in the latent variables</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EM-algorithm-and-K-means"><span class="nav-number">3.7.</span> <span class="nav-text">EM algorithm and K-means</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Benefits-of-Introducing-Latent-Variables"><span class="nav-number">3.8.</span> <span class="nav-text">Benefits of Introducing Latent Variables</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Application-of-Monte-Carlo-Method-in-the-EM-Algorithm"><span class="nav-number">3.9.</span> <span class="nav-text">Application of Monte Carlo Method in the EM Algorithm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Generalized-EM-Algorithm"><span class="nav-number">3.10.</span> <span class="nav-text">Generalized EM Algorithm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Wake-Sleep-algorithm"><span class="nav-number">3.11.</span> <span class="nav-text">Wake-Sleep algorithm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Generalized-EM-Algorithm-and-Gibbs-Sampling"><span class="nav-number">3.12.</span> <span class="nav-text">Generalized EM Algorithm and Gibbs Sampling</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Variational-Inference"><span class="nav-number">4.</span> <span class="nav-text">Variational Inference</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ELBO"><span class="nav-number">4.1.</span> <span class="nav-text">ELBO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Variational-inference-on-arbitrary-distributions"><span class="nav-number">4.2.</span> <span class="nav-text">Variational inference on arbitrary distributions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exponential-family-distribution"><span class="nav-number">4.3.</span> <span class="nav-text">Exponential family distribution</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Variational-Inference-under-Exponential-Family-Distributions"><span class="nav-number">4.4.</span> <span class="nav-text">Variational Inference under Exponential Family Distributions</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bayesian-Inference"><span class="nav-number">5.</span> <span class="nav-text">Bayesian Inference</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Markov-Chain-Monte-Carlo"><span class="nav-number">6.</span> <span class="nav-text">Markov Chain Monte Carlo</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%87%E6%A0%B7"><span class="nav-number">6.1.</span> <span class="nav-text">采样</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%92%E7%BB%9D%E9%87%87%E6%A0%B7"><span class="nav-number">6.2.</span> <span class="nav-text">拒绝采样</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E5%BA%94%E6%80%A7%E6%8B%92%E7%BB%9D%E9%87%87%E6%A0%B7"><span class="nav-number">6.3.</span> <span class="nav-text">适应性拒绝采样</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E6%80%A7%E9%87%87%E6%A0%B7"><span class="nav-number">6.4.</span> <span class="nav-text">重要性采样</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E5%92%8CMetropolis-Hasting%E7%AE%97%E6%B3%95"><span class="nav-number">6.5.</span> <span class="nav-text">马尔可夫蒙特卡洛和Metropolis-Hasting算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hybrid-Metropolis-Hasting"><span class="nav-number">6.6.</span> <span class="nav-text">Hybrid Metropolis-Hasting</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%89%E5%B8%83%E6%96%AF%E9%87%87%E6%A0%B7"><span class="nav-number">6.7.</span> <span class="nav-text">吉布斯采样</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Expectation-Maximization"><span class="nav-number">7.</span> <span class="nav-text">Expectation Maximization</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0"><span class="nav-number">7.1.</span> <span class="nav-text">更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AC%E5%BC%8F"><span class="nav-number">7.2.</span> <span class="nav-text">公式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BD%95%E6%9C%89%E6%95%88"><span class="nav-number">7.3.</span> <span class="nav-text">为何有效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8EELBO%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3"><span class="nav-number">7.4.</span> <span class="nav-text">从ELBO的角度理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E5%81%87%E8%AE%BE%E9%9A%90%E5%8F%98%E9%87%8F%E4%B8%BA%E5%8F%AF%E8%A7%82%E5%AF%9F%E7%9A%84%E8%A7%92%E5%BA%A6"><span class="nav-number">7.5.</span> <span class="nav-text">从假设隐变量为可观察的角度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E5%81%87%E8%AE%BE%E9%9A%90%E5%8F%98%E9%87%8F%E4%B8%BA%E7%BC%BA%E5%A4%B1%E5%80%BC%E7%9A%84%E8%A7%92%E5%BA%A6"><span class="nav-number">7.6.</span> <span class="nav-text">从假设隐变量为缺失值的角度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EM%E7%AE%97%E6%B3%95%E4%B8%8EK-means"><span class="nav-number">7.7.</span> <span class="nav-text">EM算法与K-means</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%90%E5%8F%98%E9%87%8F%E5%BC%95%E5%85%A5%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">7.8.</span> <span class="nav-text">隐变量引入的好处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8EM%E7%AE%97%E6%B3%95%E4%B8%AD%E5%BA%94%E7%94%A8%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95"><span class="nav-number">7.9.</span> <span class="nav-text">在EM算法中应用蒙特卡罗方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89EM%E7%AE%97%E6%B3%95"><span class="nav-number">7.10.</span> <span class="nav-text">广义EM算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Wake-Sleep%E7%AE%97%E6%B3%95"><span class="nav-number">7.11.</span> <span class="nav-text">Wake-Sleep算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BF%E4%B9%89EM%E7%AE%97%E6%B3%95%E4%B8%8E%E5%90%89%E5%B8%83%E6%96%AF%E9%87%87%E6%A0%B7"><span class="nav-number">7.12.</span> <span class="nav-text">广义EM算法与吉布斯采样</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Variational-Inference"><span class="nav-number">8.</span> <span class="nav-text">Variational Inference</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ELBO"><span class="nav-number">8.1.</span> <span class="nav-text">ELBO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E5%88%86%E5%B8%83%E4%B8%8A%E7%9A%84%E5%8F%98%E5%88%86%E6%8E%A8%E6%96%AD"><span class="nav-number">8.2.</span> <span class="nav-text">任意分布上的变分推断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E6%95%B0%E5%AE%B6%E6%97%8F%E5%88%86%E5%B8%83"><span class="nav-number">8.3.</span> <span class="nav-text">指数家族分布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E6%95%B0%E6%97%8F%E5%88%86%E5%B8%83%E4%B8%8B%E7%9A%84%E5%8F%98%E5%88%86%E6%8E%A8%E6%96%AD"><span class="nav-number">8.4.</span> <span class="nav-text">指数族分布下的变分推断</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Thinkwee</p>
  <div class="site-description" itemprop="description">Failed Better</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/thinkwee" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;thinkwee" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:thinkwee2767@gmail.com" title="E-Mail → mailto:thinkwee2767@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/thinkwee2767" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;thinkwee2767" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://scholar.google.com/citations?hl=en&user=QvW2leIAAAAJ" title="GScholar → https:&#x2F;&#x2F;scholar.google.com&#x2F;citations?hl&#x3D;en&amp;user&#x3D;QvW2leIAAAAJ" rel="noopener me" target="_blank"><i class="fa fa-graduation-cap fa-fw"></i>GScholar</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://thinkwee.top/2018/08/28/inference-algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Thinkwee">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thinkwee's Blog">
      <meta itemprop="description" content="Failed Better">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Note for Inference Algorithms in Probabilistic ML | Thinkwee's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Note for Inference Algorithms in Probabilistic ML
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-08-28 09:55:10" itemprop="dateCreated datePublished" datetime="2018-08-28T09:55:10+08:00">2018-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-07-16 18:40:20" itemprop="dateModified" datetime="2025-07-16T18:40:20+08:00">2025-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ML/" itemprop="url" rel="index"><span itemprop="name">ML</span></a>
        </span>
    </span>

  
    <span id="/2018/08/28/inference-algorithm/" class="post-meta-item leancloud_visitors" data-flag-title="Note for Inference Algorithms in Probabilistic ML" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>49k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>44 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><img data-src="https://i.mji.rip/2025/07/16/cbd846ecd88abb611db2c204930d896d.png" width="500"/></p>
<p>Record the principles and derivations of algorithms used for inferring unknown variables in probabilistic machine learning, such as Variational Inference, Expectation Maximization, and Markov Chain Monte Carlo. Many contents and derivations, as well as images, come from the online course and lecture notes of Professor Xu Yida at the University of Technology Sydney. Professor Xu’s series of videos on non-parametric Bayesian methods are very good, and you can find the videos by searching his name on Bilibili or Youku. The address of Professor Xu’s course notes is <a target="_blank" rel="noopener" href="https://github.com/roboticcam/machine-learning-notes">roboticcam/machine-learning-notes</a>. Unless otherwise specified, some screenshots and code are from Professor Xu’s lecture notes. Other contents come from various books or tutorials, and the references will be indicated in the text.</p>
<span id="more"></span>
<p><img data-src="https://s1.ax1x.com/2018/10/19/iwWPun.png" alt="iwWPun.png"></p>
<style>.lang-content {width: 100%;overflow: hidden;}.lang-content:not(:first-child) {display: none;}</style><div style="text-align: right; margin: 0 0 20px auto; max-width: 200px;"><button id="langToggle" onclick="toggleLanguage()" class="lang-switch-btn" style="width: 100%;padding: 10px 20px;border-radius: 8px;border: 2px solid #2c3e50;background-color: #fff;cursor: pointer;color: #2c3e50;font-size: 15px;transition: all 0.3s ease;display: flex;align-items: center;justify-content: center;gap: 8px;box-shadow: 0 2px 4px rgba(0,0,0,0.1);"><span class="button-text">切换中文</span></button></div>
<div id="en-content" class="lang-content" style="display: block;"><h1 id="Bayesian-Inference"><a href="#Bayesian-Inference" class="headerlink" title="Bayesian Inference"></a>Bayesian Inference</h1><ul>
<li>In Bayesian inference, it is necessary to distinguish observable quantities (data) from unknown variables (which may be statistical parameters, missing data, or latent variables)</li>
<li>Statistical parameters are regarded as random variables in the Bayesian framework, and we need to make probabilistic estimates of the model’s parameters. In the frequentist framework, parameters are determined and non-random quantities, mainly used for probabilistic estimates of the data</li>
<li>In the frequentist framework, only the likelihood is focused on $p(x|\theta)$ , while the Bayesian school believes that the parameters $\theta$ should be treated as variables, making prior assumptions about the parameters $p(\theta)$ before observing the data</li>
<li>Posterior proportionality to the product of likelihood and prior, representing the parameter probability distribution we obtain after adjusting the prior for the observed data</li>
<li>In the Bayesian framework, we are more concerned with precision, which is the reciprocal of variance, for example, in the posterior of a normal distribution, precision is the sum of the precision of the prior and the data</li>
<li>The posterior is actually a balance between the maximum likelihood estimation and the prior</li>
<li>As the amount of data increases, the posterior gradually ceases to depend on the prior</li>
<li>Many times, we do not have prior knowledge, in which case a flat, dispersed distribution is generally used as the prior distribution, such as a uniform distribution with a wide range or a normal distribution with a large variance</li>
<li>Sometimes we do not need to know the entire posterior distribution but only make some point estimates or interval estimates</li>
</ul>
<h1 id="Markov-Chain-Monte-Carlo"><a href="#Markov-Chain-Monte-Carlo" class="headerlink" title="Markov Chain Monte Carlo"></a>Markov Chain Monte Carlo</h1><ul>
<li>MCMC, the first MC stands for how to sample so that the sampling points satisfy the distribution, and the second MC stands for using random sampling to estimate the parameters of the distribution</li>
<li>Maximum likelihood estimation and the EM algorithm are both point estimations, while MCMC finds the complete posterior distribution through sampling</li>
<li>Monte Carlo simple sampling is known for its distribution, but it is not possible to directly calculate certain statistics of functions on this distribution. Therefore, statistics are indirectly calculated by generating samples through random sampling of this distribution and then using the samples to compute the statistics</li>
<li>Monte Carlo inference involves an unknown distribution and known samples (data), where the distribution is inferred from the samples (question mark pending determination)</li>
</ul>
<h2 id="Sampling"><a href="#Sampling" class="headerlink" title="Sampling"></a>Sampling</h2><ul>
<li><p>It is difficult (or the distribution is unknown) to derive some statistical quantities directly through the distribution function; we can obtain the statistical quantities by generating a series of samples that conform to this distribution and calculating the statistical quantities through sample statistics, i.e., by random sampling</p>
</li>
<li><p>In parameter inference, we can randomly sample a series of samples from the posterior distribution that satisfies the parameters, thereby estimating the parameters based on the samples</p>
</li>
<li><p>The simplest sampling: inverse sampling from the cumulative distribution function, which is first performing a uniform distribution sampling from [0,1], and then using this value as the output of the cdf function; the sampling value is the input to the cdf:</p>
<script type="math/tex; mode=display">
u = U(0,1) \\
x= cdf ^{-1} (u) \\</script></li>
</ul>
<h2 id="Refuse-Sampling"><a href="#Refuse-Sampling" class="headerlink" title="Refuse Sampling"></a>Refuse Sampling</h2><ul>
<li><p>Not all cumulative distribution functions of distributions are easy to invert. Another sampling method is called rejection sampling.</p>
</li>
<li><p>For a probability density function, we cannot sample it directly, so we construct a distribution that is everywhere greater than the probability density function, surrounding this function, as shown in the figure where the red line encloses the green line <img data-src="https://s1.ax1x.com/2018/10/20/i0oFwd.jpg" alt="i0oFwd.jpg"> </p>
</li>
<li><p>We calculate the distance of each point to the red line and the green line, dividing it into acceptance and rejection regions. Thus, we first sample from the red distribution to obtain samples, and then perform a [0,1] uniform distribution sampling. If the sample falls within the acceptance region, it is accepted; otherwise, it is rejected</p>
</li>
<li><p>显然红色分布处处比绿色大是不可能的，积分不为 1，因此需要按比例放缩一下，乘以一个系数 M，算法如下：</p>
<pre><code>i=0
while i!= N
x(i)~q(x) and u~U(0,1)
if u&lt; p(x(i))/Mq(x(i)) then
   accept x(i)
   i=i+1
else
   reject x(i)
end
end
</code></pre></li>
</ul>
<ul>
<li>rejection sampling efficiency is too low because if the red distribution is not chosen well, and it cannot tightly enclose the green distribution, the acceptance rate is too low, and most samples will be rejected.</li>
</ul>
<h2 id="Adaptive-Rejection-Sampling"><a href="#Adaptive-Rejection-Sampling" class="headerlink" title="Adaptive Rejection Sampling"></a>Adaptive Rejection Sampling</h2><ul>
<li>When the distribution is log-concave, we can effectively construct the envelope of the green distribution, which means the red distribution is closer to the green distribution and has a higher acceptance rate</li>
<li>The basic idea is to divide the green distribution to be sampled into k regions, with the leftmost point in each region serving as the starting point. If the green distribution at the starting point in each region can be enveloped by its tangent line, we can then use the tangent lines on these k regions to form the red region</li>
<li>However, this requires that the original distribution be concave in each region, but for example, the probability density function of the Gaussian distribution is not a concave function; however, the Gaussian distribution becomes concave after taking the logarithm, which is what is called log-concave. Therefore, we first take the logarithm, draw the tangent, and then calculate the exponential to return to the original distribution, obtaining the k-segment tangents of the original distribution. <img data-src="https://s1.ax1x.com/2018/10/20/i0oEFI.jpg" alt="i0oEFI.jpg"> </li>
</ul>
<h2 id="Importance-Sampling"><a href="#Importance-Sampling" class="headerlink" title="Importance Sampling"></a>Importance Sampling</h2><ul>
<li><p>The sampling algorithm mentioned above samples from a simple distribution (proposed distribution), calculates the acceptance rate for each sample through the relationship between the simple distribution and the complex distribution, and rejects some samples to ensure that the remaining samples satisfy the complex distribution</p>
</li>
<li><p>The idea of importance sampling is to weight the sample points rather than simply rejecting or accepting them, thus fully utilizing each sample point.</p>
</li>
<li><p>For example, we hope to obtain the expected value of a distribution through sampling</p>
<script type="math/tex; mode=display">
E_{p(x)}(f(x)) = \int _x f(x)p(x)dx \\
E_{p(x)}(f(x)) = \int _x f(x) \frac{p(x)}{q(x)} q(x) dx \\
E_{p(x)}(f(x)) = \int _x g(x)q(x)dx \\</script></li>
<li><p>p(x) is difficult to sample, so we convert it to sampling from q(x). Here, $\frac{p(x)}{q(x)}$ represents the importance weight.</p>
</li>
<li><p>We thus eliminate the restriction that the red distribution must envelop the green distribution, as long as we calculate the importance weights and perform importance weighting on the sampled points, we can obtain some statistical quantities under the green distribution.</p>
</li>
</ul>
<h2 id="Markov-Monte-Carlo-and-Metropolis-Hastings-algorithms"><a href="#Markov-Monte-Carlo-and-Metropolis-Hastings-algorithms" class="headerlink" title="Markov Monte Carlo and Metropolis-Hastings algorithms"></a>Markov Monte Carlo and Metropolis-Hastings algorithms</h2><ul>
<li><p>MCMC is another sampling method, where the sample sequence is regarded as a Markov chain, and the samples sampled by MCMC are not independent; the probability distribution of the next sample is related to the previous sample</p>
</li>
<li><p>Different from the concepts of general sampling acceptance or rejection, MCMC calculates the probability distribution of the next sample’s position under the premise of the current sample after each sample, which is the key transition probability.</p>
</li>
<li><p>After sampling a sample, we draw the next one according to the transition probability, obtaining a series of samples that conform to the given distribution. It is evident that the transition probability needs to be related to the given distribution. We utilize the convergence of the Markov chain, hoping that the distribution after convergence, denoted as $\pi$ , is the given distribution, assuming the transition probability is denoted as $k(x^{‘} | x)$ , from sample $x$ to sample $x^{‘}$ .</p>
</li>
<li><p>In the Markov chain, there is the following Chapman-Kolmogorov equation:</p>
<script type="math/tex; mode=display">
\pi _t (x^{'}) = \int _x \pi _{t-1}(x) k(x^{'} | x) dx</script></li>
<li><p>The significance of this formula is self-evident. We hope to achieve the convergence of Markov chains. After convergence, regardless of how the transition is made, the sequence of samples obtained should satisfy the same given distribution, then the requirement is:</p>
<script type="math/tex; mode=display">
\pi _t (x) = \pi _{t-1} (x)</script></li>
<li><p>Actual use relies on another important formula, known as the detailed balance condition:</p>
<script type="math/tex; mode=display">
\pi (x) k(x^{'} | x) = \pi (x^{'}) k(x | x^{'})</script></li>
<li><p>From detailed balance, it can be deduced that the Chapman-Kologronvo equation holds, but the converse is not necessarily true.</p>
</li>
<li><p>When the detailed balance condition is satisfied, the Markov chain is convergent</p>
</li>
<li><p>In the LDA blog, mh and Gibbs are introduced, and Metropolis-Hasting is the result of the basic MCMC where the acceptance rate on one side is raised to 1: <img data-src="https://s1.ax1x.com/2018/10/20/i0okTA.jpg" alt="i0okTA.jpg"> </p>
</li>
<li><p>In the mh, we did not alter the transition matrix to adapt to the given distribution, but instead used the given distribution to correct the transition matrix, thus, the transition matrix is one that we ourselves designed. Generally, the transition matrix (proposal distribution) is designed as a Gaussian distribution centered around the current state. For this Gaussian distribution, when the variance is small, the probability is concentrated around the current sampling point, so the position transferred to the next sampling point is unlikely to change much, resulting in a high acceptance rate (since the current sampling point is the one that passed the acceptance, it is likely to be in a position with a high acceptance rate). However, this will cause the random walk to be slow; if the variance is large, it will wander everywhere, and the acceptance rate will decrease.</p>
</li>
<li><p>Despite one side’s sample acceptance rate reaching 1, there is always one side below 1. If it is rejected, the MCMC will repeat sampling at the same location once and then continue.</p>
</li>
<li><p>And Gibbs raised both acceptance rates to 1, which shows that Gibbs is a special case of MCMC. MCMC does not modify the transition probability but adds the acceptance rate, linking the original transition probability with the distribution to be sampled. However, it is obvious that if we ourselves choose the transition probability and make it more closely related to the original distribution, the effect will be better, and Gibbs follows this approach.</p>
</li>
</ul>
<h2 id="Hybrid-Metropolis-Hasting"><a href="#Hybrid-Metropolis-Hasting" class="headerlink" title="Hybrid Metropolis-Hasting"></a>Hybrid Metropolis-Hasting</h2><ul>
<li>To be supplemented</li>
</ul>
<h2 id="Gibbs-Sampling"><a href="#Gibbs-Sampling" class="headerlink" title="Gibbs Sampling"></a>Gibbs Sampling</h2><ul>
<li><p>A motivation for Gibbs sampling: It is difficult to sample directly from the joint distribution of multiple parameters, but if other parameters are fixed as conditions, sampling from the conditional distribution of just one parameter becomes much simpler, and it can be proven that the samples obtained after convergence satisfy the joint distribution</p>
</li>
<li><p>Firstly, let’s consider why the Gibbs sampling process does not change the joint probability distribution through iterative conditional sampling. Firstly, when excluding the i-th parameter to calculate the conditional probability, the marginal distribution of the excluded n-1 variables is the same as the marginal distribution of the true joint probability distribution for these n-1 variables, because their values have not changed; the condition on which the conditional probability is based is unchanged compared to the true distribution, so the conditional probability distribution is also unchanged. Both the marginal distribution and the conditional probability distribution are unchanged (true), so the joint distribution obtained by multiplying them is naturally unchanged, and therefore, in each iteration step, sampling is done according to the true distribution and the iteration does not change this distribution.</p>
</li>
<li><p>Gibbs sampling is a coordinate descent method similar to variational inference, updating one component of the sample at a time, based on the conditional probability of the current updating component’s dimension given the other components: <img data-src="https://s1.ax1x.com/2018/10/20/i0oVYt.jpg" alt="i0oVYt.jpg"> </p>
</li>
<li><p>Industrial applications of Gibbs sampling are widespread due to its speed. In fact, such an iterative algorithm cannot be parallelized, but the collapsed Gibbs sampling can parallelize the iteration. The principle is to treat several components as a whole, collapsing them into one component. When other components are updated using this set of components, they are considered independent (there is some doubt; another way to describe collapse is to ignore some conditional variables. Basic Gibbs sampling is essentially collapsed Gibbs sampling, and the approach of treating several components as a whole is blocked Gibbs sampling):</p>
<pre><code>u~p(u|x,y,z)
x,y,z~p(x,y,z|u)
=p(x|u)p(y|u)p(z|u)
</code></pre></li>
</ul>
<ul>
<li><p>The three conditional probabilities concerning x, y, and z can be computed in parallel.</p>
</li>
<li><p>Now we prove that Gibbs is a special case of Metropolis-Hastings with an acceptance rate of 1, let’s first look at the acceptance rate of Metropolis-Hastings</p>
<script type="math/tex; mode=display">
\alpha = min(1,\frac{\pi (x^{'}),q(x| x^{'})}{\pi (x) q(x^{'} | x)})</script></li>
<li><p>In Gibbs</p>
<script type="math/tex; mode=display">
q(x|x^{'})=\pi (x_i | x_{¬i}^{'}) \\
q(x^{'}|x)=\pi (x_i ^{'} | x_{¬i}) \\</script></li>
<li><p>And in fact, from $x<em>{¬i}$ to $x</em>{¬i}^{‘}$ , only the ith component changes, with the other components remaining unchanged, therefore</p>
<script type="math/tex; mode=display">
x_{¬i}^{'}=x_{¬i}</script></li>
<li><p>Next, let’s examine Gibbs’ acceptance rate</p>
<script type="math/tex; mode=display">
\alpha _{gibbs} =  min(1,\frac{\pi (x^{'}) \pi (x_i | x_{¬i}^{'})}{\pi (x) (x_i ^{'} | x_{¬i})}) \\</script><script type="math/tex; mode=display">
= min(1,\frac{\pi (x^{'}) \pi (x_i | x_{¬i})}{\pi (x) (x_i ^{'} | x_{¬i})}) \\</script><script type="math/tex; mode=display">
= min(1,\frac{\pi (x^{'} |  x_{¬i}^{'}) \pi( x_{¬i}^{'}) \pi (x_i | x_{¬i})}{\pi (x_i | x_{¬i}) \pi( x_{¬i}) (x_i ^{'} | x_{¬i})}) \\</script><script type="math/tex; mode=display">
= min(1,\frac{\pi (x^{'} |  x_{¬i}) \pi( x_{¬i}) \pi (x_i | x_{¬i})}{\pi (x_i | x_{¬i}) \pi( x_{¬i}) (x_i ^{'} | x_{¬i})}) \\</script><script type="math/tex; mode=display">
= min(1,1) \\</script><script type="math/tex; mode=display">
= 1 \\</script></li>
</ul>
<h1 id="Expectation-Maximization"><a href="#Expectation-Maximization" class="headerlink" title="Expectation Maximization"></a>Expectation Maximization</h1><h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><ul>
<li>deep|bayes2018 mentions using stochastic gradient descent for the M-step in EM, as it is stochastic, the E-step only targets a portion of the data, reducing overhead, and enabling inference of latent variable models on large-scale datasets. At the time, it was applied to word2vec, adding a qualitative latent variable for each word to indicate one of its multiple meanings, aiming to resolve ambiguity issues, and even parameterize the number of word meanings using the Chinese restaurant process. Will look at it in detail when I have time.</li>
</ul>
<h2 id="Formula"><a href="#Formula" class="headerlink" title="Formula"></a>Formula</h2><ul>
<li>For simple distributions, we want to perform parameter inference, which only requires maximum likelihood estimation, first calculating the log-likelihood:</li>
</ul>
<script type="math/tex; mode=display">
\theta=\mathop{argmax}_{\theta} L(X | \theta) \\
=\mathop{argmax}_{\theta} \log \prod p(x_i | \theta) \\
=\mathop{argmax}_{\theta} \sum \log p(x_i | \theta) \\</script><ul>
<li><p>Afterward, differentiate the log-likelihood to calculate the extrema; however, for complex distributions, it may not be convenient to differentiate</p>
</li>
<li><p>We can use the EM algorithm to iteratively solve this. The EM algorithm considers the latent variables in the probabilistic generative model and assigns probabilities to them, updating their probability distribution and the parameter $\theta$ simultaneously with each iteration. It can be proven that after each iteration, the obtained $\theta$ will increase the log-likelihood.</p>
</li>
<li><p>Each iteration is divided into two parts, E and M, which correspond to seeking the expectation and maximization</p>
<ul>
<li>The expectation is the expectation of $\log p(x,z|\theta)$ over the distribution $p(z|x,\theta ^{(t)})$ , where $\theta ^{(t)}$ is the parameter calculated at the t-th iteration</li>
<li>Maximization, that is, seeking the $\theta$ that maximizes this expectation, as the result of the parameter update in this iteration</li>
</ul>
</li>
<li><p>The formula for the EM algorithm is obtained when combined:</p>
<script type="math/tex; mode=display">
\theta ^{(t+1)} = \mathop{argmax} _{\theta} \int p(z|x,\theta ^{(t)}) \log p(x,z|\theta) dz</script><h2 id="Why-Effective"><a href="#Why-Effective" class="headerlink" title="Why Effective"></a>Why Effective</h2></li>
<li><p>That is to prove, the maximum likelihood will increase after each iteration</p>
</li>
<li><p>To prove:</p>
<script type="math/tex; mode=display">
\log p(x|\theta ^{(t+1)}) \geq \log p(x|\theta ^{(t)})</script></li>
<li><p>Reformulate the log-likelihood</p>
<script type="math/tex; mode=display">
\log p(x|\theta) = \log p(x,z|\theta) - \log p(z|x,\theta) \\</script></li>
<li><p>Both sides of the distribution $p(z|x,\theta ^{(t)})$ calculate the expectation, noting that the left side of the equation is independent of z, therefore, after calculating the expectation, it remains unchanged:</p>
<script type="math/tex; mode=display">
\log p(x|\theta) = \int _z \log p(x,z|\theta) p(z|x,\theta ^{(t)}) dz - \int _z \log p(z|x,\theta) p(z|x,\theta ^{(t)}) dz \\
=Q(\theta,\theta ^{(t)})-H(\theta,\theta ^{(t)}) \\</script></li>
<li><p>The Q part is the E part of the EM algorithm, note that here $\theta$ is a variable, $\theta ^{(t)}$ is a constant</p>
</li>
<li><p>After the iteration, due to the role of the M part in the EM algorithm, the Q part must have increased (greater than or equal to), then what will the new $\theta$ after this iteration that makes the Q part increase change when substituted into the H part?</p>
</li>
<li><p>We first calculate, assuming that the $\theta$ of section H remains unchanged, directly using the previous $\theta ^{(t)}$ to input, that is, $H(\theta ^{(t)},\theta ^{(t)})$</p>
<script type="math/tex; mode=display">
H(\theta ^{(t)},\theta ^{(t)})-H(\theta,\theta ^{(t)})= \\</script><script type="math/tex; mode=display">
\int _z \log p(z|x,\theta ^{(t)}) p(z|x,\theta ^{(t)}) dz - \int _z \log p(z|x,\theta) p(z|x,\theta ^{(t)}) dz \\</script><script type="math/tex; mode=display">
= \int _z \log (\frac {p(z|x,\theta ^{(t)})} {p(z|x,\theta)} ) p(z|x,\theta ^{(t)}) dz \\</script><script type="math/tex; mode=display">
= - \int _z \log (\frac {p(z|x,\theta)} {p(z|x,\theta ^{(t)})} ) p(z|x,\theta ^{(t)}) dz \\</script><script type="math/tex; mode=display">
\geq - \log \int _z  (\frac {p(z|x,\theta)} {p(z|x,\theta ^{(t)})} ) p(z|x,\theta ^{(t)}) dz \\</script><script type="math/tex; mode=display">
= - \log 1 \\</script><script type="math/tex; mode=display">
= 0 \\</script></li>
<li><p>The inequality in question utilizes the Jensen inequality. That is, directly using the previous $\theta ^{(t)}$ as $\theta$ to substitute into H is the maximum value of H! Then, regardless of how much $\theta ^{(t+1)}$ is obtained from the new argmax Q part, substituting it into H will cause the H part to decrease (less than or equal to) ! The numerator becomes larger, and the denominator smaller, so the result is that the log-likelihood is definitely larger, which proves the effectiveness of the EM algorithm.</p>
</li>
</ul>
<h2 id="Understanding-from-the-perspective-of-the-Evidence-Lower-Bound-ELBO"><a href="#Understanding-from-the-perspective-of-the-Evidence-Lower-Bound-ELBO" class="headerlink" title="Understanding from the perspective of the Evidence Lower Bound (ELBO)"></a>Understanding from the perspective of the Evidence Lower Bound (ELBO)</h2><ul>
<li><p>We can also derive the formula for the EM algorithm from the perspective of ELBO (Evidence Lower Bound)</p>
</li>
<li><p>In the previous rewriting of the log-likelihood, we obtained two expressions $p(x,z|\theta)$ and $p(z|x,\theta)$ . We introduce a distribution $q(z)$ of latent variables, and by computing the KL divergence between these two expressions and $q(z)$ , we can prove that the log-likelihood is the difference between these two KL divergences:</p>
<script type="math/tex; mode=display">
KL(q(z)||p(z|x,\theta)) = \int q(z) [\log q(z) - \log p(z|x,\theta)] dz \\</script><script type="math/tex; mode=display">
= \int q(z) [\log q(z) - \log p(x|z,\theta) - \log (z|\theta) + \log p(x|\theta)] dz \\</script><script type="math/tex; mode=display">
= \int q(z) [\log q(z) - \log p(x|z,\theta) - \log (z|\theta)] dz + \log p(x|\theta) \\</script><script type="math/tex; mode=display">
= \int q(z) [\log q(z) - \log p(x,z|\theta)] dz + \log p(x|\theta) \\</script><script type="math/tex; mode=display">
= KL(q(z)||p(x,z|\theta)) + \log p(x|\theta) \\</script></li>
<li><p>That is to say</p>
<script type="math/tex; mode=display">
\log p(x|\theta) = - KL(q(z)||p(x,z|\theta)) + KL(q(z)||p(z|x,\theta))</script></li>
<li><p>ELBO is the evidence lower bound, because of $KL(q(z)||p(z|x,\theta)) \geq 0$ , thus ELBO is a lower bound for the log-likelihood. We can maximize this lower bound to maximize the log-likelihood.</p>
</li>
<li><p>It can be seen that the ELBO has two parameters, $q$ and $\theta$ . First, we fix $\theta ^{(t-1)}$ , and find the $q^{(t)}$ that maximizes the ELBO, which is actually the E-step of the EM algorithm. Next, we fix $q^{(t)}$ , and find the $\theta ^{(t)}$ that maximizes the ELBO, which corresponds to the M-step of the EM algorithm</p>
</li>
<li><p>We substitute $\theta = \theta ^{(t-1)}$ into the ELBO expression:</p>
<script type="math/tex; mode=display">
ELBO=\log p(x|\theta ^{(t-1)}) - KL(q(z)||p(z|x,\theta ^{(t-1)}))</script></li>
<li><p>What value of q maximizes the ELBO? It is obvious that when the KL divergence is 0, the ELBO reaches its maximum value, which is when the lower bound reaches the logarithmic likelihood itself, at which point $q(z)=p(z|x,\theta ^{(t-1)})$ , next we fix $q$ , and seek the value of $\theta$ that maximizes the ELBO, first rewriting the definition of ELBO:</p>
<script type="math/tex; mode=display">
ELBO = - KL(q(z)||p(x,z|\theta)) \\</script><script type="math/tex; mode=display">
= \int q^{(t)}(z) [ \log p(x,z|\theta) - \log q^{(t)}(z)] dz \\</script><script type="math/tex; mode=display">
= - \int q^{(t)}(z) \log p(x,z|\theta) - q^{(t)}(z) \log q^{(t)}(z) dz \\</script></li>
<li><p>The second item is unrelated to $\theta$ , therefore:</p>
<script type="math/tex; mode=display">
\theta ^{(t)} = \mathop{argmax} _{\theta} \int q^{(t)}(z) \log p(x,z|\theta) dz \\</script></li>
<li><p>Substitute the $q(z)=p(z|x,\theta ^{(t-1)})$ obtained in the previous step, and we get</p>
<script type="math/tex; mode=display">
\theta ^{(t)} = \mathop{argmax} _{\theta} \int \log p(x,z|\theta)p(z|x,\theta ^{(t-1)}) dz</script></li>
<li><p>Similarly, the iterative formula of the EM algorithm is obtained</p>
</li>
<li><p>The following two figures are extracted from Christopher M. Bishop’s Pattern Recognition and Machine Learning, illustrating what the E-step and M-step actually do: The E-step raises the lower bound ELBO to the log-likelihood, but at this point only the latent variables are updated, so the log-likelihood does not change. When the updated latent variables are used to update the parameters $\theta$ , i.e., after the M-step is executed, we continue to obtain a higher ELBO and its corresponding log-likelihood. At this time, q does not change, but p changes, so KL is not 0, and the log-likelihood must be greater than the ELBO, i.e., it will increase. Intuitively, we increase the ELBO in both the E and M steps; the E-step first raises the ELBO to the log-likelihood in one go, and then the M-step can still increase the ELBO, but the log-likelihood will definitely be greater than or equal to (in fact, greater than) the ELBO at the M-step, so the log-likelihood is “pushed up” by the ELBO increased by the M-step. <img data-src="https://s1.ax1x.com/2018/10/20/i0oZfP.png" alt="i0oZfP.png"> <img data-src="https://s1.ax1x.com/2018/10/20/i0ou6S.png" alt="i0ou6S.png">  </p>
</li>
<li><p>The remaining issue is how to select z and q; in the mixed model, z can be introduced as an indicator function, while the other probability models containing latent variables can directly introduce the latent variables during design</p>
</li>
</ul>
<h2 id="From-the-perspective-of-assuming-latent-variables-to-be-observable"><a href="#From-the-perspective-of-assuming-latent-variables-to-be-observable" class="headerlink" title="From the perspective of assuming latent variables to be observable"></a>From the perspective of assuming latent variables to be observable</h2><ul>
<li>This understanding comes from the tutorial by Chuong B Do &amp; Serafim Batzoglou: What is the Expectation Maximization Algorithm?</li>
<li>EM is used for inference in probabilistic models with unobserved latent variables. In fact, if we make the latent variables observable from unobserved, and perform maximum likelihood estimation for each possible value of the latent variables, we can still obtain results, but the time cost is quite high.</li>
<li>EM then improves this naive algorithm. One understanding of the EM algorithm is: The EM algorithm first guesses a probability distribution of the hidden variables in each iteration, creates a weighted training set considering all possible values of the hidden variables, and then performs a modified version of maximum likelihood estimation on it.</li>
<li>Guessing the probability distribution of a hidden variable is the E-step, but we do not need to know the specific probability distribution; we only need to calculate the expectation of the sufficient statistic on this distribution.</li>
<li>The EM algorithm is a natural generalization of maximum likelihood estimation to data containing hidden variables (or data containing partially unobserved samples).</li>
</ul>
<h2 id="From-the-perspective-of-missing-values-in-the-latent-variables"><a href="#From-the-perspective-of-missing-values-in-the-latent-variables" class="headerlink" title="From the perspective of missing values in the latent variables"></a>From the perspective of missing values in the latent variables</h2><ul>
<li>How are missing values generally handled? Replaced with random values, mean values, 0 values, cluster center values, etc</li>
<li>EM is equivalent to replacing missing values with the mean, i.e., the latent variable, but it utilizes more information: this mean is obtained by taking the expectation over the known distribution of x</li>
<li>The EM iteration involves repeatedly processing missing values (latent variables), then adjusting the distribution of x based on the complete data, and finally treating the latent variables as missing values for adjustment</li>
</ul>
<h2 id="EM-algorithm-and-K-means"><a href="#EM-algorithm-and-K-means" class="headerlink" title="EM algorithm and K-means"></a>EM algorithm and K-means</h2><ul>
<li>K-means is a Hard-EM algorithm that, like the EM algorithm, makes assumptions about various possible latent variables (the class to which the sample belongs), but it does not calculate probabilities and expectations on the class level. Instead, it is more rigid, specifying only one class as the sample’s class, with a probability of 1 for this class and 0 for all others.</li>
</ul>
<h2 id="Benefits-of-Introducing-Latent-Variables"><a href="#Benefits-of-Introducing-Latent-Variables" class="headerlink" title="Benefits of Introducing Latent Variables"></a>Benefits of Introducing Latent Variables</h2><ul>
<li><p>In fact, it should be said the other way around: many times, we design latent variables based on logic and then use the EM algorithm to infer the latent variables, rather than deliberately designing latent variables to simplify computation.</p>
</li>
<li><p>For GMM, one advantage of introducing latent variables is that it simplifies the computation of maximum likelihood estimation (of course, this is under the assumption that we know the latent variables), by exchanging the logarithm with the summation operation, referring to the blog of the great pluskid: On Clustering (Extra Chapter): Expectation Maximization</p>
</li>
<li><p>Before introducing latent variables as indicator functions for GMM, the maximum likelihood estimation is:</p>
<script type="math/tex; mode=display">
\sum _{i=1}^N \log (\sum _{k=1}^K \pi _k N(x_i | \mu _k , \Sigma _k))</script></li>
<li><p>After introducing latent variables, the indicator function corresponding to the ith sample $x_i$ is $z_i$ , which is a k-dimensional one-hot vector representing which of the k Gaussian models the ith sample belongs to. If it belongs to the mth model, then $z_i^m$ equals 1, and the rest are 0. Now, the maximum likelihood estimation is:</p>
<script type="math/tex; mode=display">
\log \prod _{i=1}^N p(x_i,z_i) \\</script><script type="math/tex; mode=display">
= \log \prod _{i=1}^N p(z_i) \prod _{k=1}^K N(x_i | \mu _k , \Sigma _k)^{z_i^k} \\</script><script type="math/tex; mode=display">
= \log \prod _{i=1}^N  \prod _{k=1}^K \pi _k ^{z_i^k} \prod _{k=1}^K N(x_i | \mu _k , \Sigma _k)^{z_i^k} \\</script><script type="math/tex; mode=display">
= \log \prod _{i=1}^N  \prod _{k=1}^K ( \pi _k N(x_i | \mu _k , \Sigma _k)) ^{z_i^k} \\</script><script type="math/tex; mode=display">
= \sum _{i=1}^N \sum _{k=1}^K z_i^k(\log \pi _k + \log N(x_i | \mu _k , \Sigma _k)) \\</script></li>
</ul>
<h2 id="Application-of-Monte-Carlo-Method-in-the-EM-Algorithm"><a href="#Application-of-Monte-Carlo-Method-in-the-EM-Algorithm" class="headerlink" title="Application of Monte Carlo Method in the EM Algorithm"></a>Application of Monte Carlo Method in the EM Algorithm</h2><ul>
<li><p>When the E-step cannot parse the computation, the integral of the M-step can be approximated using Monte Carlo methods:</p>
<script type="math/tex; mode=display">
\theta ^{(t+1)} = \mathop{argmax} _{\theta} \int p(z|x,\theta ^{(t)}) \log p(x,z|\theta) dz</script></li>
<li><p>We sample a finite number of $Z^l$ based on the posterior estimate $p(z|x,\theta ^{(t)})$ of the latent variables obtained now, and then substitute these $Z^l$ into $\log p(x,z|\theta)$ to approximate the integral:</p>
<script type="math/tex; mode=display">
\theta ^{(t+1)} = \mathop{argmax} _{\theta} \approx \frac 1L \sum_{l=1}^L  \log p(x,Z^l|\theta)</script></li>
<li><p>An extreme example of the Monte Carlo EM algorithm is the random EM algorithm, which is equivalent to sampling only one sample point in the E-step at each iteration. In the solution of mixed models, the latent variables act as indicator functions, and sampling only one latent variable implies hard assignment, with each sample point assigned to a component with a probability of 1.</p>
</li>
<li><p>Monte Carlo EM algorithm extended to the Bayesian framework results in the IP algorithm</p>
<ul>
<li><p>I steps:</p>
<script type="math/tex; mode=display">
p(Z|X)=\int p(Z | \theta ,X)p(\theta | X)d\theta</script><p>Sample from $p(\theta | X)$ , then substitute into it, and subsequently sample from $p(Z | \theta ^l ,X)$ into $Z^l$ .</p>
</li>
<li><p>P-step: Sampling from the I-step obtained $Z^l$ for estimating the posterior parameters:</p>
<script type="math/tex; mode=display">
p(\theta | X) = \int p(\theta | Z,X)p(Z|X) dZ  \\
\approx \frac 1L \sum _{l=1}^L p(\theta | Z^l,X) \\</script></li>
</ul>
</li>
</ul>
<h2 id="Generalized-EM-Algorithm"><a href="#Generalized-EM-Algorithm" class="headerlink" title="Generalized EM Algorithm"></a>Generalized EM Algorithm</h2><ul>
<li>Will not chicken out</li>
</ul>
<h2 id="Wake-Sleep-algorithm"><a href="#Wake-Sleep-algorithm" class="headerlink" title="Wake-Sleep algorithm"></a>Wake-Sleep algorithm</h2><ul>
<li>Pigeon Ethics Philosophy</li>
</ul>
<h2 id="Generalized-EM-Algorithm-and-Gibbs-Sampling"><a href="#Generalized-EM-Algorithm-and-Gibbs-Sampling" class="headerlink" title="Generalized EM Algorithm and Gibbs Sampling"></a>Generalized EM Algorithm and Gibbs Sampling</h2><ul>
<li>When you think I won’t chicken out and I do, it’s also a form of not chickening out</li>
</ul>
<h1 id="Variational-Inference"><a href="#Variational-Inference" class="headerlink" title="Variational Inference"></a>Variational Inference</h1><h2 id="ELBO"><a href="#ELBO" class="headerlink" title="ELBO"></a>ELBO</h2><ul>
<li><p>Next, we introduce variational inference, and it can be seen that the EM algorithm can be generalized to variational inference</p>
</li>
<li><p>Reintroducing the relationship between ELBO and log-likelihood:</p>
<script type="math/tex; mode=display">
\log p(x) = \log p(x,z) - \log p(z|x) \\
= \log \frac{p(x,z)}{q(z)} - \log \frac{p(z|x)}{q(z)} \\
= \log p(x,z) - \log q(z) - \log \frac{p(z|x)}{q(z)} \\</script></li>
<li><p>Seek the expectation of the hidden distribution $q(z)$ on both sides</p>
<script type="math/tex; mode=display">
\log p(x) = \\
[ \int _z q(z) \log p(x,z)dz - \int _z q(z) \log q(z)dz ] + [- \int _z \log \frac{p(z|x)}{q(z)} q(z) dz ]\\
= ELBO+KL(q||p(z|x)) \\</script></li>
<li><p>We hope to infer the posterior distribution of the latent variable $z$ , for this purpose, we introduce a distribution $q(z)$ to approximate this posterior. Under the premise of the current observations, i.e., the log-likelihood, the approximation of the posterior is equivalent to minimizing the KL divergence between $q(z)$ and $p(z|x)$ . From the above formula, it can be seen that when the ELBO is maximized, the KL divergence is minimized.</p>
</li>
<li><p>Next is the discussion on how to maximize the ELBO</p>
</li>
</ul>
<h2 id="Variational-inference-on-arbitrary-distributions"><a href="#Variational-inference-on-arbitrary-distributions" class="headerlink" title="Variational inference on arbitrary distributions"></a>Variational inference on arbitrary distributions</h2><ul>
<li><p>For any distribution, update one component of the latent variable at a time, such as the jth component</p>
</li>
<li><p>Ourself-selected $q(z)$ is of course simpler than the approximate distribution; here, it is assumed that the distribution is independent, and the latent variable is $M$ -dimensional:</p>
<script type="math/tex; mode=display">
q(z)=\prod _{i=1}^M q_i(z_i)</script></li>
<li><p>Therefore, the ELBO can be expressed in two parts</p>
<script type="math/tex; mode=display">
ELBO=\int \prod q_i(z_i) \log p(x,z) dz - \int \prod q_j(z_j) \sum \log q_j(z_j) dz \\
=part1-part2 \\</script></li>
<li><p>The part1 can be expressed in the form of multiple integrals over the various dimensions of the latent variables, and we select the jth dimension to rewrite it as</p>
<script type="math/tex; mode=display">
part1=\int \prod q_i(z_i) \log p(x,z) dz \\</script><script type="math/tex; mode=display">
= \int _{z_1} \int _{z_2} ... \int _{z_M} \prod _{i=1}^M q_i(z_i) \log p(x,z) d z_1 , d z_2 , ... ,d z_M \\</script><script type="math/tex; mode=display">
= \int _{z_j} q_j(z_j) ( \int _{z_{i \neq j}} \log (p(x,z)) \prod _{z_{i \neq j}} q_i(z_i) d z_i) d z_j \\</script><script type="math/tex; mode=display">
= \int _{z_j}  q_j(z_j) [E_{i \neq j} [\log (p(x,z))]] d z_j \\</script></li>
<li><p>In this context, we define a form of pseudo-distribution, which is the pseudo-distribution of a distribution, obtained by integrating the logarithm of the distribution and then exponentiating the result:</p>
<script type="math/tex; mode=display">
p_j(z_j) = \int _{i \neq j} p(z_1,...,z_i) d z_1 , d z_2 ,..., d z_i \\</script><script type="math/tex; mode=display">
p_j^{'}(z_j) = exp \int _{i \neq j} \log p(z_1,...,z_i) d z_1 , d z_2 ,..., d z_i \\</script><script type="math/tex; mode=display">
\log p_j^{'}(z_j)  = \int _{i \neq j} \log p(z_1,...,z_i) d z_1 , d z_2 ,..., d z_i \\</script></li>
<li><p>This part 1 can be rewritten in the form of pseudo-distribution</p>
<script type="math/tex; mode=display">
part1= \int _{z_j} q_j(z_j) \log p_j^{'}(x,z_j) \\</script></li>
<li><p>In part 2, because the components of the latent variables are independent, the sum of the function can be rewritten as the sum of the expectations of each function over the marginal distributions, in which we focus on the j-th variable, treating the rest as constants:</p>
<script type="math/tex; mode=display">
part2=\int \prod q_j(z_j) \sum \log q_j(z_j) dz \\</script><script type="math/tex; mode=display">
= \sum ( \int q_i(z_i) \log (q_i(z_i)) d z_i ) \\</script><script type="math/tex; mode=display">
= \int q_j(z_j) \log (q_j(z_j)) d z_j + const \\</script></li>
<li><p>Combine part 1 and part 2 to obtain the form of the ELBO for component j:</p>
<script type="math/tex; mode=display">
ELBO = \int _{z_j} \log \log p_j^{'}(x,z_j) -  \int q_j(z_j) \log (q_j(z_j)) d z_j + const \\</script><script type="math/tex; mode=display">
= \int _{z_j} q_j(z_j) \log \frac{p_j^{'}(x,z_j)}{q_j(z_j)} + const \\</script><script type="math/tex; mode=display">
= - KL(p_j^{'}(x,z_j) || q_j(z_j)) + const\\</script></li>
<li><p>The ELBO is written as the negative KL divergence between a pseudo-distribution and an approximate distribution, maximizing the ELBO is equivalent to minimizing this KL divergence</p>
</li>
<li><p>When is this KL divergence minimum? That is to say:</p>
<script type="math/tex; mode=display">
q_j(z_j) = p_j^{'}(x,z_j) \\
\log q_j(z_j) = E_{i \neq j} [\log (p(x,z))] \\</script></li>
<li><p>We have obtained the iterative formula for the approximate distribution of a single component of the latent variables under variational inference. When calculating the probability of the jth component, the expectation over all other components $q_i(z_i)$ is used, and then this new probability of the jth component participates in the next iteration, calculating the probabilities of the other components.</p>
</li>
</ul>
<h2 id="Exponential-family-distribution"><a href="#Exponential-family-distribution" class="headerlink" title="Exponential family distribution"></a>Exponential family distribution</h2><ul>
<li><p>Define the exponential family distribution:</p>
<script type="math/tex; mode=display">
p(x | \theta)=h(x) exp(\eta (\theta) \cdot T(x)-A(\theta)) \\</script></li>
<li><p>Amongst</p>
<ul>
<li>sufficient statistics</li>
<li>$\theta$:parameter of the family</li>
<li>$\eta$:natural parameter</li>
<li>underlying measure</li>
<li>$A(\theta)$ : log normalizer / partition function</li>
</ul>
</li>
<li><p>Attention: The parameter of the family and the natural parameter are both vectors. When the exponential family distribution is in the form of scalar parameters, i.e., $\eta _i (\theta) = \theta _i$ , the exponential family distribution can be written as:</p>
<script type="math/tex; mode=display">
p(x | \eta)=h(x) exp(\eta (T(x) ^T \eta - A(\eta))</script></li>
<li><p>When we express the probability density function in the exponential family form, we have:</p>
<script type="math/tex; mode=display">
\eta = \mathop{argmax} _ {\eta} [\log p(X | \eta)] \\</script><script type="math/tex; mode=display">
= \mathop{argmax} _ {\eta} [\log \prod p(x_i | \eta)] \\</script><script type="math/tex; mode=display">
= \mathop{argmax} _ {\eta} [\log [\prod h(x_i) exp [(\sum T(x_i))^T \eta - n A(\eta)]]] \\</script><script type="math/tex; mode=display">
= \mathop{argmax} _ {\eta} (\sum T(x_i))^T \eta - n A(\eta)] \\</script><script type="math/tex; mode=display">
= \mathop{argmax} _ {\eta} L(\eta) \\</script></li>
<li><p>Continuing to seek extrema, we can obtain a very important property of the exponential family distribution regarding the log normalizer and sufficient statistics:</p>
<script type="math/tex; mode=display">
\frac{\partial L (\eta)}{\partial \eta} = \sum T(x_i) - n A^{'}(\eta) =0 \\</script><script type="math/tex; mode=display">
A^{'}(\eta) = \sum \frac{T(x_i)}{n} \\</script></li>
<li><p>For example, the Gaussian distribution is written in the form of an exponential family distribution:</p>
<script type="math/tex; mode=display">
p(x) = exp[- \frac{1}{2 \sigma ^2}x^2 + \frac{\mu}{\sigma ^2}x - \frac{\mu ^2}{2 \sigma ^2} - \frac 12 \log(2 \pi \sigma ^2)] \\</script><script type="math/tex; mode=display">
=exp ( [x \ x^2] [\frac{\mu}{\sigma ^2} \ \frac{-1}{2 \sigma ^2}] ^T - \frac{\mu ^2}{2 \sigma ^2} - \frac 12 \log(2 \pi \sigma ^2) )</script></li>
<li><p>Using natural parameters to replace variance and mean, expressed in the exponential family distribution form:</p>
<script type="math/tex; mode=display">
p(x) = exp( [x \ x^2] [ \eta _1 \ \eta _2] ^T + \frac{\eta _1 ^2}{4 \eta _2} + \frac 12 \log (-2 \eta _2 ) - \frac 12 \log (2 \pi))</script></li>
<li><p>Wherein:</p>
<ul>
<li>$T(x)$:$[x \ x^2]$</li>
<li>$\eta$:$[ \eta _1 \ \eta _2] ^T$</li>
<li>$-A(\eta)$:$\frac{\eta _1 ^2}{4 \eta _2} + \frac 12 \log (-2 \eta _2 )$</li>
</ul>
</li>
<li><p>Next, we utilize the properties of the exponential family to quickly calculate the mean and variance</p>
<script type="math/tex; mode=display">
A^{'}(\eta) = \sum \frac{T(x_i)}{n} \\</script><script type="math/tex; mode=display">
[\frac{\partial A}{\eta _1} \ \frac{\partial A}{\eta _2}] = [\frac{- \eta _1}{2 \eta _2} \ \frac{\eta _1 ^2 }{2 \eta _2}-\frac{1}{2 \eta _2}] \\</script><script type="math/tex; mode=display">
= [\frac{\sum x_i}{n} \ \frac{\sum x_i^2}{n}] \\</script><script type="math/tex; mode=display">
= [\mu \ \mu ^2 + \sigma ^2] \\</script></li>
<li><p>Why is $A(\eta)$ called log normalizer? Because the integral of the exponential family distribution of the probability density has:</p>
<script type="math/tex; mode=display">
\int _x \frac{h(x)exp(T(x)^T \eta)}{exp(A(\eta))} = 1 \\</script><script type="math/tex; mode=display">
A(\eta) = \log \int _x h(x)exp(T(x)^T \eta) \\</script></li>
<li><p>Below discusses the conjugate relationships of exponential family distributions, assuming that both the likelihood and the prior are exponential family distributions:</p>
<script type="math/tex; mode=display">
p(\beta | x) ∝ p(x | \beta) p(\beta) \\</script><script type="math/tex; mode=display">
∝ h(x) exp(T(x) \beta ^T - A_l (\beta)) h(\beta) exp(T(\beta) \alpha ^T - A(\alpha)) \\</script></li>
<li><p>Rewritten in the form of a vector group:</p>
<script type="math/tex; mode=display">
T(\beta) = [\beta \ -g(\beta)] \\</script><script type="math/tex; mode=display">
\alpha = [\alpha _1 \ \alpha _2] \\</script></li>
<li><p>In the original expression, $\beta$ , $h(x)$ , and $A(\alpha)$ are all constants, which are eliminated from the proportional expression and then substituted into the vector group:</p>
<script type="math/tex; mode=display">
∝ h(\beta) exp(T(x) \beta - A_l(\beta) + \alpha _1 \beta - \alpha _2 g(\beta)) \\</script></li>
<li><p>We note that if we let $-g(\beta)=-A_l (\beta)$ , the original expression can be written as:</p>
<script type="math/tex; mode=display">
∝ h(\beta) exp((T(x)+\alpha _1)\beta - (1+\alpha _2) A_l (\beta)) \\</script><script type="math/tex; mode=display">
∝ h(\beta) exp(\alpha _1 ^{'} \beta - \alpha _2 ^{'} A_l (\beta)) \\</script></li>
<li><p>The prior and posterior forms are consistent, that is, conjugate</p>
</li>
<li><p>We thus write down the likelihood and prior in a unified form</p>
<script type="math/tex; mode=display">
p(\beta | x, \alpha) ∝ p(x | \beta) p(\beta | \alpha) \\</script><script type="math/tex; mode=display">
∝ h(x)exp[T(x)^T\beta - A_l(\beta)] h(\beta) exp[T(\beta)^T\alpha - A_l(\alpha)] \\</script></li>
<li><p>Here we can calculate the derivative of the log normalizer with respect to the parameters, note that this is a calculated result, different from the properties of the log normalizer and sufficient statistics obtained from the maximum likelihood estimation of the exponential family distribution</p>
<script type="math/tex; mode=display">
\frac{\partial A_l(\beta)}{\partial \beta}=\int _x T(x) p(x | \beta)dx \\</script><script type="math/tex; mode=display">
= E_{p(x|\beta)} [T(x)] \\</script></li>
<li><p>The above equation can be proven by integrating over the exponential family distribution with the integral equal to 1, and taking the derivative with respect to $\beta$ yields 0, transforming this equation to prove it.</p>
</li>
</ul>
<h2 id="Variational-Inference-under-Exponential-Family-Distributions"><a href="#Variational-Inference-under-Exponential-Family-Distributions" class="headerlink" title="Variational Inference under Exponential Family Distributions"></a>Variational Inference under Exponential Family Distributions</h2><ul>
<li><p>Next, we will express the parameter posterior in the ELBO in the form of an exponential family distribution, and it can be seen that the final iteration formula is quite concise</p>
</li>
<li><p>We assume that there are two parameters to be optimized, x and z, and we use $\lambda$ and $\phi$ to approximate $\eta(z,x)$ and $\eta(\beta ,x)$ . The goal remains to maximize the ELBO, at which point the adjusted parameter is $q(\lambda , \phi)$ , which is actually $\lambda$ and $\phi$</p>
</li>
<li><p>We adopt a method of fixing one parameter and optimizing another, iteratively making the ELBO larger</p>
</li>
<li><p>First, we rewrite the ELBO, noting $q(z,\beta)=q(z)q(\beta)$</p>
<script type="math/tex; mode=display">
ELBO=E_{q(z,\beta)}[\log p(x,z,\beta)] - E_{q(z,\beta)}[\log p(z,\beta)] \\</script><script type="math/tex; mode=display">
= E_{q(z,\beta)}[\log p(\beta | x,z) + \log p(z | x) + \log p(x)] - E_{q(z,\beta)}[\log q(\beta)] - E_{q(z,\beta)}[\log q(z)] \\</script></li>
<li><p>The posterior is distributed in the exponential family, and the q-distribution is approximated using simple parameters $\lambda$ and $\phi$</p>
<script type="math/tex; mode=display">
p(\beta | x,z) = h(\beta) exp [ T(\beta) ^T \eta (z,x) - A_g (\eta(z,x))] \\</script><script type="math/tex; mode=display">
\approx q(\beta | \lambda) \\</script><script type="math/tex; mode=display">
= h(\beta) exp [ T(\beta) ^T \eta (\lambda - A_g (\eta(\lambda))] \\</script><script type="math/tex; mode=display">
p(z | x,\beta) = h(z) exp [ T(z) ^T \eta (\beta,x) - A_l (\eta(\beta,x))] \\</script><script type="math/tex; mode=display">
\approx q(\beta | \phi) \\</script><script type="math/tex; mode=display">
= h(z) exp [ T(z) ^T \eta (\phi - A_l (\eta(\phi))] \\</script></li>
<li><p>Now we fix $\phi$ , optimize $\lambda$ , and remove irrelevant constants from the ELBO, yielding:</p>
<script type="math/tex; mode=display">
ELBO_{\lambda} = E_{q(z,\beta)}[\log p(\beta | x,z)] - E_{q(z,\beta)}[\log q(\beta)] \\</script></li>
<li><p>Substitute the exponential family distribution, eliminate the irrelevant constant $- E_{q(z)}[A_g(\eta(x,z))]$ , and simplify to obtain:</p>
<script type="math/tex; mode=display">
ELBO_{\lambda} = E_{q(\beta)}[T(\beta)^T] E_{q(z)}[\eta(z,x)]  -E_{q(\beta)} [T(\beta)^T \lambda] + A_g(\lambda)</script></li>
<li><p>Using the conclusions from the previous log normalizer regarding parameter differentiation, we have:</p>
<script type="math/tex; mode=display">
ELBO_{\lambda} = A_g^{'}(\lambda)^T[E_{q(z)}[\eta(z,x)]] - \lambda A_g^{'}(\lambda) ^T + A_g (\lambda)</script></li>
<li><p>Differentiate the above equation, set it to 0, and we have:</p>
<script type="math/tex; mode=display">
A_g^{''}(\lambda)^T[E_{q(z)}[\eta(z,x)]] - A_g^{'}(\lambda)-\lambda A_g^{''}(\lambda) ^T + A_g^{} (\lambda) = 0 \\
\lambda = E_{q(z)}[\eta(z,x)] \\</script></li>
<li><p>We have obtained the iterative $\lambda$ ! Similarly, we can obtain:</p>
<script type="math/tex; mode=display">
\phi = E_{q(\beta)}[\eta(\beta,x)] \\</script></li>
<li><p>Should be written as:</p>
<script type="math/tex; mode=display">
\lambda = E_{q(z | \phi)}[\eta(z,x)] \\
\phi = E_{q(\beta | \lambda)}[\eta(\beta,x)] \\</script></li>
<li><p>The variable update paths for these two iterative processes are:</p>
<script type="math/tex; mode=display">
\lambda \rightarrow q(\beta | \lambda) \rightarrow \phi \rightarrow q(z | \phi) \rightarrow \lambda</script></li>
</ul>
</div>
<div id="zh-content" class="lang-content" style="display: none;"><h1 id="Bayesian-Inference"><a href="#Bayesian-Inference" class="headerlink" title="Bayesian Inference"></a>Bayesian Inference</h1><ul>
<li>在贝叶斯推断中，需要区别可观察量（数据）和未知变量（可能是统计参数、缺失数据、隐变量）</li>
<li>统计参数在贝叶斯框架中被看成是随机变量，我们需要对模型的参数进行概率估计，而在频率学派的框架下，参数是确定的非随机的量，主要针对数据做概率估计</li>
<li>在频率学派框架中只关注似然$p(x|\theta)$，而贝叶斯学派认为应将参数$\theta$作为变量，在观察到数据之前，对参数做出先验假设$p(\theta)$</li>
<li>后验正比与似然乘以先验，代表观察到数据后我们对参数先验调整，得到的参数概率分布</li>
<li>在贝叶斯框架中我们更关注精确度，它是方差的倒数，例如在正态分布的后验中，精确度是先验和数据的精确度之和</li>
<li>后验实际上是在最大似然估计和先验之间权衡</li>
<li>当数据非常多时，后验渐渐不再依赖于先验</li>
<li>很多时候我们并没有先验知识，这时一般采用平坦的、分散的分布作为先验分布，例如范围很大的均匀分布，或者方差很大的正态分布</li>
<li>有时我们并不需要知道整个后验分布，而仅仅做点估计或者区间估计</li>
</ul>
<h1 id="Markov-Chain-Monte-Carlo"><a href="#Markov-Chain-Monte-Carlo" class="headerlink" title="Markov Chain Monte Carlo"></a>Markov Chain Monte Carlo</h1><ul>
<li>MCMC，前一个MC代表如何采样，使得采样点满足分布，后一个MC代表用随机采样来估计分布的参数</li>
<li>最大似然估计和EM算法都是点估计，而MCMC是通过采样找出完整的后验分布</li>
<li>蒙特卡洛单纯做抽样，是已知分布，但无法直接求得某些函数在此分布上的统计量，因此间接的通过对此分布随机抽样产生样本，通过样本计算统计量</li>
<li>蒙特卡洛做推断，则是分布未知，已知样本（数据），通过样本反推分布（？待确定）</li>
</ul>
<h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><ul>
<li>直接通过分布函数很难（或者分布未知）推出一些统计量，我们可以通过产生一系列符合这个分布的样本，通过样本统计计算统计量，即随机采样的方式获得统计量</li>
<li>在参数推断中，我们可以随机采样出一系列满足参数的后验分布的样本，从而依靠样本估计参数</li>
<li><p>最简单的采样：从累计分布函数的逆采样，也就是先从[0,1]做一个均匀分布的采样，然后这个值作为cdf函数的输出值，采样值即cdf的输入值：</p>
<script type="math/tex; mode=display">
u = U(0,1) \\
x= cdf ^{-1} (u) \\</script></li>
</ul>
<h2 id="拒绝采样"><a href="#拒绝采样" class="headerlink" title="拒绝采样"></a>拒绝采样</h2><ul>
<li>但是不是所有分布的累积分布函数取逆都容易得到。另外一种采样方法叫做rejection sampling</li>
<li>对于一个概率密度函数，我们无法直接采样，那么就做一个处处大于概率密度函数的分布，包围着这个函数，如图中红色线包住了绿色线<br><img data-src="https://s1.ax1x.com/2018/10/20/i0oFwd.jpg" alt="i0oFwd.jpg"></li>
<li>我们计算出每个点到红线和绿线的距离，将其分为接受和拒绝区域，这样，我们先从红色分布采样得到样本，然后做一个[0,1]均匀分布采样，如果落在接收区域则接收该采样，否则拒接</li>
<li><p>显然红色分布处处比绿色大是不可能的，积分不为1，因此需要按比例放缩一下，乘以一个系数M，算法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i=0</span><br><span class="line">while i!= N</span><br><span class="line">x(i)~q(x) and u~U(0,1)</span><br><span class="line">if u&lt; p(x(i))/Mq(x(i)) then</span><br><span class="line">   accept x(i)</span><br><span class="line">   i=i+1</span><br><span class="line">else</span><br><span class="line">   reject x(i)</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li>rejection sampling效率太低，因为若红色分布选择不好，不能紧紧包住绿色分布时，接受率太低，大部分采样会被拒绝。</li>
</ul>
<h2 id="适应性拒绝采样"><a href="#适应性拒绝采样" class="headerlink" title="适应性拒绝采样"></a>适应性拒绝采样</h2><ul>
<li>当分布是log-concave的时候，我们能够有效的构造绿色分布的包络，也就是红色分布比较贴近绿色分布，接受率较高</li>
<li>基本思想是，将要采样的绿色分布分为k个区域，每个区域最左边的点作为起始点，如果在每个区域能够用绿色分布在起始点的切线来包络的话，我们就可以用这个k个区域上的切线来组成红色区域</li>
<li>但是这要求在各个区域内原始分布是凹的，但是例如高斯分布的概率密度函数并不是凹函数，但是高斯分布取对数之后是凹的，也就是所谓log-concave，因此我们先取对数，作出切线，然后计算指数还原到原分布，得到原分布的k段切线。<br><img data-src="https://s1.ax1x.com/2018/10/20/i0oEFI.jpg" alt="i0oEFI.jpg"></li>
</ul>
<h2 id="重要性采样"><a href="#重要性采样" class="headerlink" title="重要性采样"></a>重要性采样</h2><ul>
<li>上面提到的采样算法是从简单分布（提议分布）采样，通过简单分布和复杂分布之间的关系计算每个样本的接受率，拒绝掉一些样本，使得剩下的样本满足复杂分布</li>
<li>importance sampling的思路是对样本点加权而不是简单粗暴的拒绝或者接收，这样可以充分利用每个样本点。</li>
<li><p>例如我们希望通过采样得到某个分布的期望</p>
<script type="math/tex; mode=display">
E_{p(x)}(f(x)) = \int _x f(x)p(x)dx \\
E_{p(x)}(f(x)) = \int _x f(x) \frac{p(x)}{q(x)} q(x) dx \\
E_{p(x)}(f(x)) = \int _x g(x)q(x)dx \\</script></li>
<li>p(x)难以采样，我们就转化为从q(x)采样。其中$\frac{p(x)}{q(x)}$就是importance weight。</li>
<li>这样我们消除了红色分布必须包络住绿色分布的限制，只要计算出重要性权重，对采样出的样本点进行重要性加权，就可以得到绿色分布下的一些统计量。</li>
</ul>
<h2 id="马尔可夫蒙特卡洛和Metropolis-Hasting算法"><a href="#马尔可夫蒙特卡洛和Metropolis-Hasting算法" class="headerlink" title="马尔可夫蒙特卡洛和Metropolis-Hasting算法"></a>马尔可夫蒙特卡洛和Metropolis-Hasting算法</h2><ul>
<li>mcmc是另一种采样方法，他将样本序列看作马尔可夫链，通过mcmc采样出的样本之间不是独立的，下一个样本的概率分布与上一个样本有关</li>
<li>不同于普通采样的接收或者拒绝的概念，在每采样一个样本之后，mcmc会计算在当前样本的前提下，下一个样本的位置的概率分布，也就是关键的转移概率。</li>
<li>我们抽样一个样本之后，按照转移概率我们抽下一个，得到一系列样本，符合给定的分布，显然这个转移概率是需要和给定分布相关的。我们利用马尔可夫链的收敛性，希望收敛之后的分布$\pi$就是给定分布，假定转移概率为$k(x^{‘} | x)$，从样本$x$转移到样本$x^{‘}$。</li>
<li><p>在马尔可夫链中，有如下Chapman-Kologronvo等式：</p>
<script type="math/tex; mode=display">
\pi _t (x^{'}) = \int _x \pi _{t-1}(x) k(x^{'} | x) dx</script></li>
<li><p>这个公式的意义显而易见。我们希望得到马氏链收敛，收敛之后无论怎么转移，得到的一系列样本都满足同一给定分布，则要求：</p>
<script type="math/tex; mode=display">
\pi _t (x) = \pi _{t-1} (x)</script></li>
<li><p>实际使用时我们依赖于另一个重要的公式，叫做细致平稳条件，the detailed balance：</p>
<script type="math/tex; mode=display">
\pi (x) k(x^{'} | x) = \pi (x^{'}) k(x | x^{'})</script></li>
<li>由detailed balance可以推出Chapman-Kologronvo等式，反之不一定。</li>
<li>当满足细致平稳条件时，马氏链是收敛的</li>
<li>在LDA的博客里介绍了mh和gibbs，Metropolis-Hasting就是基本mcmc将一边的接受率提到1的结果：<br><img data-src="https://s1.ax1x.com/2018/10/20/i0okTA.jpg" alt="i0okTA.jpg"></li>
<li>在mh中，我们没有改变转移矩阵来适应给定分布，而是用给定分布来修正转移矩阵，因此，转移矩阵是我们自己设计的。一般将转移矩阵（提议分布）设计为以当前状态为中心的高斯分布，对于这个高斯分布，当方差很小时，概率集中在本次采样点附近，那么转移到下次采样时大概率位置不会变动很多，接受率高（因为本次采样点就是通过了接收得到的，大概率是处于高接受率的位置），但这会造成随机游走缓慢；如果方差很大，到处走，接受率就会降低。</li>
<li>尽管一边的样本接受率提到了1，但总有一边低于1，如果被拒绝，则mcmc会原地重复采样一次，再继续。</li>
<li>而gibbs则将两边的接受率都提到了1，可以看出，gibbs是mh的一种特例。mh没有修改转移概率，而是添加了接受率，将原先的转移概率和需要采样的分布联系起来。但是显然如果我们自己选择转移概率，且使得转移概率和原始分布的联系越密切，那效果越好，gibbs就是这样的思路。</li>
</ul>
<h2 id="Hybrid-Metropolis-Hasting"><a href="#Hybrid-Metropolis-Hasting" class="headerlink" title="Hybrid Metropolis-Hasting"></a>Hybrid Metropolis-Hasting</h2><ul>
<li>待补充</li>
</ul>
<h2 id="吉布斯采样"><a href="#吉布斯采样" class="headerlink" title="吉布斯采样"></a>吉布斯采样</h2><ul>
<li>吉布斯采样的一个动机：对于多个参数的联合分布，很难直接采样，但是如果固定其他参数作为条件，仅仅对一个参数的条件分布做采样，这时采样会简单许多，且可以证明收敛之后这样采样出来的样本满足联合分布</li>
<li>先看直觉上为啥吉布斯采样通过条件概率迭代抽样的过程中不改变联合概率分布。首先在排除第i个参数计算条件概率时，这被排除的n-1个变量的边缘分布与真实联合概率分布针对这n-1个变量的边缘分布是一样的，因为它们的值没有改变；条件概率依据的条件相比真实分布是不变的，那条件概率分布也是不变的。边缘分布和条件概率分布都是不变（真实）的，那相乘得到的联合分布自然也是不变的，因此每一步迭代里都是按照真实分布采样且迭代不会改变这个分布。</li>
<li>吉本斯采样是类似变分推断的coordinate descent方法，一次更新样本的一个分量，依据的转移概率是在给定其他分量情况下当前更新分量所在维度的条件概率：<br><img data-src="https://s1.ax1x.com/2018/10/20/i0oVYt.jpg" alt="i0oVYt.jpg"></li>
<li><p>工业上吉布斯采样用的很广，因为它快，事实上这样一种迭代算法不能并行，但是利用collapsed gibbs sampling可以并行化迭代。其原理是将几个分量看成一个整体，collapse成一个分量，当其他分量用这组分量更新时，看成独立的（存在疑问，另一种关于collapse的说法是忽略一些条件变量，基本的gibbs采样就是collapsed gibbs sampling，而这种几个分量看成一个整体的做法是blocked gibbs sampling）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u~p(u|x,y,z)</span><br><span class="line">x,y,z~p(x,y,z|u)</span><br><span class="line">=p(x|u)p(y|u)p(z|u)</span><br></pre></td></tr></table></figure></li>
<li>上面关于x,y,z的三个条件概率可以并行计算。</li>
<li><p>现在我们证明gibbs是mh的一种特例且接受率为1，先看看mh的接受率</p>
<script type="math/tex; mode=display">
\alpha = min(1,\frac{\pi (x^{'}),q(x| x^{'})}{\pi (x) q(x^{'} | x)})</script></li>
<li><p>在gibbs中</p>
<script type="math/tex; mode=display">
q(x|x^{'})=\pi (x_i | x_{¬i}^{'}) \\
q(x^{'}|x)=\pi (x_i ^{'} | x_{¬i}) \\</script></li>
<li><p>而且实际上从$x<em>{¬i}$到$x</em>{¬i}^{‘}$，只有第i个分量变了，除了第i个分量之外的其他分量没有改变，因此</p>
<script type="math/tex; mode=display">
x_{¬i}^{'}=x_{¬i}</script></li>
<li><p>接下来看看gibbs的接受率</p>
<script type="math/tex; mode=display">
\alpha _{gibbs} =  min(1,\frac{\pi (x^{'}) \pi (x_i | x_{¬i}^{'})}{\pi (x) (x_i ^{'} | x_{¬i})}) \\</script><script type="math/tex; mode=display">
= min(1,\frac{\pi (x^{'}) \pi (x_i | x_{¬i})}{\pi (x) (x_i ^{'} | x_{¬i})}) \\</script><script type="math/tex; mode=display">
= min(1,\frac{\pi (x^{'} |  x_{¬i}^{'}) \pi( x_{¬i}^{'}) \pi (x_i | x_{¬i})}{\pi (x_i | x_{¬i}) \pi( x_{¬i}) (x_i ^{'} | x_{¬i})}) \\</script><script type="math/tex; mode=display">
= min(1,\frac{\pi (x^{'} |  x_{¬i}) \pi( x_{¬i}) \pi (x_i | x_{¬i})}{\pi (x_i | x_{¬i}) \pi( x_{¬i}) (x_i ^{'} | x_{¬i})}) \\</script><script type="math/tex; mode=display">
= min(1,1) \\</script><script type="math/tex; mode=display">
= 1 \\</script></li>
</ul>
<h1 id="Expectation-Maximization"><a href="#Expectation-Maximization" class="headerlink" title="Expectation Maximization"></a>Expectation Maximization</h1><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ul>
<li>看毛子的deep|bayes2018，提到了用随机梯度下降做EM的M步骤，因为是随机的，所以E步骤只针对一部分数据进行，开销小，可以实现大规模数据上的隐变量模型推断，当时应用在word2vec上，为每一个词添加了一个定性隐变量，指示该词多个意思当中的一个，以期解决歧义问题，甚至还可以用中国餐馆过程将词意个数参数化。有时间再详细看。</li>
</ul>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><ul>
<li>对于简单的分布，我们想要做参数推断，只需要做最大似然估计，先求对数似然：</li>
</ul>
<script type="math/tex; mode=display">
\theta=\mathop{argmax}_{\theta} L(X | \theta) \\
=\mathop{argmax}_{\theta} \log \prod p(x_i | \theta) \\
=\mathop{argmax}_{\theta} \sum \log p(x_i | \theta) \\</script><ul>
<li>之后对这个对数似然求导计算极值即可，但是对于复杂的分布，可能并不方便求导</li>
<li>这时我们可以用EM算法迭代求解。EM算法考虑了概率生成模型当中的隐变量，并为其分配概率，每次迭代更新其概率分布并同时更新参数$\theta$，可以证明，每一次迭代之后得到的$\theta$都会使对数似然增加。</li>
<li>每一次迭代分为两个部分，E和M，也就求期望和最大化<ul>
<li>求期望，是求$\log p(x,z|\theta)$在分布$p(z|x,\theta ^{(t)})$上的期望，其中$\theta ^{(t)}$是第t次迭代时计算出的参数</li>
<li>最大化，也就是求使这个期望最大的$\theta$，作为本次参数迭代更新的结果</li>
</ul>
</li>
<li><p>合起来就得到EM算法的公式：</p>
<script type="math/tex; mode=display">
\theta ^{(t+1)} = \mathop{argmax} _{\theta} \int p(z|x,\theta ^{(t)}) \log p(x,z|\theta) dz</script><h2 id="为何有效"><a href="#为何有效" class="headerlink" title="为何有效"></a>为何有效</h2></li>
<li>也就是证明，每次迭代后最大似然会增加</li>
<li><p>要证明：</p>
<script type="math/tex; mode=display">
\log p(x|\theta ^{(t+1)}) \geq \log p(x|\theta ^{(t)})</script></li>
<li><p>先改写对数似然</p>
<script type="math/tex; mode=display">
\log p(x|\theta) = \log p(x,z|\theta) - \log p(z|x,\theta) \\</script></li>
<li><p>两边对分布$p(z|x,\theta ^{(t)})$求期望，注意到等式左边与z无关，因此求期望之后不变：</p>
<script type="math/tex; mode=display">
\log p(x|\theta) = \int _z \log p(x,z|\theta) p(z|x,\theta ^{(t)}) dz - \int _z \log p(z|x,\theta) p(z|x,\theta ^{(t)}) dz \\
=Q(\theta,\theta ^{(t)})-H(\theta,\theta ^{(t)}) \\</script></li>
<li>其中Q部分就是EM算法中的E部分，注意在这里$\theta$是变量，$\theta ^{(t)}$是常量</li>
<li>迭代之后，由于EM算法中M部分作用，Q部分肯定变大了（大于等于），那么使Q部分变大的这个迭代之后新的$\theta$，代入H部分，H部分会怎么变化呢？</li>
<li><p>我们先计算，假如H部分的$\theta$不变，直接用上一次的$\theta ^{(t)}$带入，即$H(\theta ^{(t)},\theta ^{(t)})$</p>
<script type="math/tex; mode=display">
H(\theta ^{(t)},\theta ^{(t)})-H(\theta,\theta ^{(t)})= \\</script><script type="math/tex; mode=display">
\int _z \log p(z|x,\theta ^{(t)}) p(z|x,\theta ^{(t)}) dz - \int _z \log p(z|x,\theta) p(z|x,\theta ^{(t)}) dz \\</script><script type="math/tex; mode=display">
= \int _z \log (\frac {p(z|x,\theta ^{(t)})} {p(z|x,\theta)} ) p(z|x,\theta ^{(t)}) dz \\</script><script type="math/tex; mode=display">
= - \int _z \log (\frac {p(z|x,\theta)} {p(z|x,\theta ^{(t)})} ) p(z|x,\theta ^{(t)}) dz \\</script><script type="math/tex; mode=display">
\geq - \log \int _z  (\frac {p(z|x,\theta)} {p(z|x,\theta ^{(t)})} ) p(z|x,\theta ^{(t)}) dz \\</script><script type="math/tex; mode=display">
= - \log 1 \\</script><script type="math/tex; mode=display">
= 0 \\</script></li>
<li>其中那个不等式是利用了Jensen不等式。也就是说，直接用上一次的$\theta ^{(t)}$作为$\theta$代入H，就是H的最大值!那么无论新的由argmax Q部分得到的$\theta ^{(t+1)}$是多少，带入    H,H部分都会减小（小于等于）！被减数变大，减数变小，那么得到的结果就是对数似然肯定变大，也就证明了EM算法的有效性</li>
</ul>
<h2 id="从ELBO的角度理解"><a href="#从ELBO的角度理解" class="headerlink" title="从ELBO的角度理解"></a>从ELBO的角度理解</h2><ul>
<li>我们还可以从ELBO（Evidence Lower Bound）的角度推出EM算法的公式</li>
<li><p>在之前改写对数似然时我们得到了两个式子$p(x,z|\theta)$和$p(z|x,\theta)$，我们引入隐变量的一个分布$q(z)$，对这个两个式子做其与$q(z)$之间的KL散度，可以证明对数似然是这两个KL散度之差：</p>
<script type="math/tex; mode=display">
KL(q(z)||p(z|x,\theta)) = \int q(z) [\log q(z) - \log p(z|x,\theta)] dz \\</script><script type="math/tex; mode=display">
= \int q(z) [\log q(z) - \log p(x|z,\theta) - \log (z|\theta) + \log p(x|\theta)] dz \\</script><script type="math/tex; mode=display">
= \int q(z) [\log q(z) - \log p(x|z,\theta) - \log (z|\theta)] dz + \log p(x|\theta) \\</script><script type="math/tex; mode=display">
= \int q(z) [\log q(z) - \log p(x,z|\theta)] dz + \log p(x|\theta) \\</script><script type="math/tex; mode=display">
= KL(q(z)||p(x,z|\theta)) + \log p(x|\theta) \\</script></li>
<li><p>也就是</p>
<script type="math/tex; mode=display">
\log p(x|\theta) = - KL(q(z)||p(x,z|\theta)) + KL(q(z)||p(z|x,\theta))</script></li>
<li>其中$- KL(q(z)||p(x,z|\theta))$就是ELBO，因为$ KL(q(z)||p(z|x,\theta)) \geq 0 $，因此ELBO是对数似然的下界。我们可以通过最大化这个下界来最大化对数似然</li>
<li>可以看到，ELBO有两个参数，$q$和$\theta$，首先我们固定$\theta ^{(t-1)}$，找到使ELBO最大化的$q^{(t)}$，这一步实际上是EM算法的E步骤，接下来固定$q^{(t)}$，找到使ELBO最大化的$\theta ^{(t)}$，这一步对应的就是EM算法的M步骤</li>
<li><p>我们把$\theta = \theta ^{(t-1)}$带入ELBO的表达式：</p>
<script type="math/tex; mode=display">
ELBO=\log p(x|\theta ^{(t-1)}) - KL(q(z)||p(z|x,\theta ^{(t-1)}))</script></li>
<li><p>q取什么值时ELBO最大？显然当KL散度为0时，ELBO取到最大值，也就是下界达到对数似然本身，这时$q(z)=p(z|x,\theta ^{(t-1)})$，接下来我们固定$q$，求使ELBO最大的$\theta$，先把ELBO的定义式改写：</p>
<script type="math/tex; mode=display">
ELBO = - KL(q(z)||p(x,z|\theta)) \\</script><script type="math/tex; mode=display">
= \int q^{(t)}(z) [ \log p(x,z|\theta) - \log q^{(t)}(z)] dz \\</script><script type="math/tex; mode=display">
= - \int q^{(t)}(z) \log p(x,z|\theta) - q^{(t)}(z) \log q^{(t)}(z) dz \\</script></li>
<li><p>其中第二项与$\theta$无关，因此：</p>
<script type="math/tex; mode=display">
\theta ^{(t)} = \mathop{argmax} _{\theta} \int q^{(t)}(z) \log p(x,z|\theta) dz \\</script></li>
<li><p>代入上一步得到的$q(z)=p(z|x,\theta ^{(t-1)})$，得到</p>
<script type="math/tex; mode=display">
\theta ^{(t)} = \mathop{argmax} _{\theta} \int \log p(x,z|\theta)p(z|x,\theta ^{(t-1)}) dz</script></li>
<li>同样得到了EM算法的迭代公式</li>
<li>下面两张图截取自Christopher M. Bishop的Pattern Recognition and Machine Learning，说明了E步骤和M步骤实际在做什么：E步骤将下界ELBO提高到对数似然，但是这时只更新了隐变量，因此对数似然没有变化，而当利用更新的隐变量更新参数$\theta$，也就是M步骤执行后，我们继续获得了更高的ELBO，以及其对应的对数似然，此时q没有变化，但p发生改变，因此KL不为0，对数似然一定大于ELBO，也就是会提升。直观的来说，我们在E和M步骤都提高了ELBO，E步骤先一口气将ELBO提满到对数似然，之后M步骤依然可以提高ELBO，但对数似然肯定会大于等于（在M步骤时实际上是大于）ELBO，因此对数似然就被M步骤提升的ELBO给“顶上去了”。<br><img data-src="https://s1.ax1x.com/2018/10/20/i0oZfP.png" alt="i0oZfP.png"><br><img data-src="https://s1.ax1x.com/2018/10/20/i0ou6S.png" alt="i0ou6S.png"></li>
<li>剩下的问题就是，如何选择z以及q，在混合模型中，可以将z作为示性函数引入，其他在设计时包含隐变量的概率模型里，可以直接将隐变量引入</li>
</ul>
<h2 id="从假设隐变量为可观察的角度"><a href="#从假设隐变量为可观察的角度" class="headerlink" title="从假设隐变量为可观察的角度"></a>从假设隐变量为可观察的角度</h2><ul>
<li>这种理解来自Chuong B Do &amp; Serafim Batzoglou的tutorial:What is the expectation maximization algorithm?</li>
<li>EM用于包含不可观察隐变量的概率模型推断，事实上，如果我们将隐变量从不可观察变为可观察，针对隐变量每一种可能的取值做最大似然估计，一样可以得到结果，但其时间代价是相当高的。</li>
<li>EM则改进了这种朴素的算法。一种对EM算法的理解是：EM算法在每次迭代中先猜想一种隐变量的取值概率分布，创造一个考虑了所有隐变量取值可能的加权的训练集，然后在这上面做一个魔改版本的最大似然估计。</li>
<li>猜想一种隐变量的取值概率分布就是E步骤，但是我们不需要知道具体的概率分布，我们只需要求充分统计量在这个分布上的期望（Expectation）。</li>
<li>所以说EM算法是最大似然估计在包含隐变量的数据（或者说包含部分不可观察样本的数据）上的自然泛化。</li>
</ul>
<h2 id="从假设隐变量为缺失值的角度"><a href="#从假设隐变量为缺失值的角度" class="headerlink" title="从假设隐变量为缺失值的角度"></a>从假设隐变量为缺失值的角度</h2><ul>
<li>一般如何处理缺失值？用随机值、平均值、0值、聚类中心值代替等等</li>
<li>EM相当于用均值代替缺失值，也就是隐变量，但是利用了更多的信息：这个均值是在已知的x分布上求期望得到</li>
<li>EM的迭代就是反复处理缺失值（隐变量），然后基于完整的数据再调整x的分布，再将隐变量看成缺失值进行调整</li>
</ul>
<h2 id="EM算法与K-means"><a href="#EM算法与K-means" class="headerlink" title="EM算法与K-means"></a>EM算法与K-means</h2><ul>
<li>K-means是一种Hard-EM算法，它一样对隐变量的各种可能做出假设（样本属于的类），但是他并不是在类上计算概率和期望，而是比较Hard，只指定一个类作为样本的类，只有这个类概率为1，其余均为0。</li>
</ul>
<h2 id="隐变量引入的好处"><a href="#隐变量引入的好处" class="headerlink" title="隐变量引入的好处"></a>隐变量引入的好处</h2><ul>
<li>其实应该反过来说，很多时候我们凭借逻辑设计了隐变量，然后利用EM算法推断隐变量，而不是刻意设计隐变量来简化运算。</li>
<li>对于GMM来说，引入隐变量的一个好处是化简了最大似然估计的计算（当然这是假设我们已知隐变量的情况下），将log与求和运算交换，参考了pluskid大神的博客：<a target="_blank" rel="noopener" href="http://blog.pluskid.org/?p=81">漫谈 Clustering (番外篇): Expectation Maximization</a></li>
<li><p>对于GMM，引入隐变量作为示性函数之前，最大似然估计是：</p>
<script type="math/tex; mode=display">
\sum _{i=1}^N \log (\sum _{k=1}^K \pi _k N(x_i | \mu _k , \Sigma _k))</script></li>
<li><p>引入隐变量之后，令第i个样本$x_i$对应的示性函数为$z_i$，这是一个k维one-hot向量，代表第i个样本属于k个高斯模型中哪一个，假设属于第m个模型，则$z_i^m$等于1，其余等于0。现在最大似然估计是：</p>
<script type="math/tex; mode=display">
\log \prod _{i=1}^N p(x_i,z_i) \\</script><script type="math/tex; mode=display">
= \log \prod _{i=1}^N p(z_i) \prod _{k=1}^K N(x_i | \mu _k , \Sigma _k)^{z_i^k} \\</script><script type="math/tex; mode=display">
= \log \prod _{i=1}^N  \prod _{k=1}^K \pi _k ^{z_i^k} \prod _{k=1}^K N(x_i | \mu _k , \Sigma _k)^{z_i^k} \\</script><script type="math/tex; mode=display">
= \log \prod _{i=1}^N  \prod _{k=1}^K ( \pi _k N(x_i | \mu _k , \Sigma _k)) ^{z_i^k} \\</script><script type="math/tex; mode=display">
= \sum _{i=1}^N \sum _{k=1}^K z_i^k(\log \pi _k + \log N(x_i | \mu _k , \Sigma _k)) \\</script></li>
</ul>
<h2 id="在EM算法中应用蒙特卡罗方法"><a href="#在EM算法中应用蒙特卡罗方法" class="headerlink" title="在EM算法中应用蒙特卡罗方法"></a>在EM算法中应用蒙特卡罗方法</h2><ul>
<li><p>当E步骤无法解析的计算时，可以使用蒙特卡洛近似M步骤的积分：</p>
<script type="math/tex; mode=display">
\theta ^{(t+1)} = \mathop{argmax} _{\theta} \int p(z|x,\theta ^{(t)}) \log p(x,z|\theta) dz</script></li>
<li><p>我们根据现在得到的隐变量后验估计$p(z|x,\theta ^{(t)})$来采样有限个$Z^l$，之后将这些$Z^l$代入$\log p(x,z|\theta)$来近似积分：</p>
<script type="math/tex; mode=display">
\theta ^{(t+1)} = \mathop{argmax} _{\theta} \approx \frac 1L \sum_{l=1}^L  \log p(x,Z^l|\theta)</script></li>
<li>蒙特卡洛EM算法的一个极端的例子是随机EM算法，相当于每次迭代只在E步骤只采样一个样本点。在混合模型求解中，隐变量作为示性函数，只采样一个隐变量意味着hard assignment，每个样本点以1概率分配到某个component，</li>
<li><p>蒙特卡洛EM算法推广到贝叶斯框架，就得到IP算法</p>
<ul>
<li><p>I步骤：</p>
<script type="math/tex; mode=display">
p(Z|X)=\int p(Z | \theta ,X)p(\theta | X)d\theta</script><p>先从$p(\theta | X)$中采样$\theta ^l$，再将其代入，接着从$p(Z | \theta ^l ,X)$中采样$Z^l$。</p>
</li>
<li><p>P步骤：<br>从I步骤采样得到的$Z^l$用于估计参数后验：</p>
<script type="math/tex; mode=display">
p(\theta | X) = \int p(\theta | Z,X)p(Z|X) dZ  \\
\approx \frac 1L \sum _{l=1}^L p(\theta | Z^l,X) \\</script></li>
</ul>
</li>
</ul>
<h2 id="广义EM算法"><a href="#广义EM算法" class="headerlink" title="广义EM算法"></a>广义EM算法</h2><ul>
<li>不会鸽</li>
</ul>
<h2 id="Wake-Sleep算法"><a href="#Wake-Sleep算法" class="headerlink" title="Wake-Sleep算法"></a>Wake-Sleep算法</h2><ul>
<li>鸽德哲学</li>
</ul>
<h2 id="广义EM算法与吉布斯采样"><a href="#广义EM算法与吉布斯采样" class="headerlink" title="广义EM算法与吉布斯采样"></a>广义EM算法与吉布斯采样</h2><ul>
<li>当你认为我不会鸽的时候鸽了，亦是一种不鸽</li>
</ul>
<h1 id="Variational-Inference"><a href="#Variational-Inference" class="headerlink" title="Variational Inference"></a>Variational Inference</h1><h2 id="ELBO"><a href="#ELBO" class="headerlink" title="ELBO"></a>ELBO</h2><ul>
<li>接下来介绍变分推断，可以看到，EM算法可以推广到变分推断</li>
<li><p>重新推出ELBO与对数似然的关系：</p>
<script type="math/tex; mode=display">
\log p(x) = \log p(x,z) - \log p(z|x) \\
= \log \frac{p(x,z)}{q(z)} - \log \frac{p(z|x)}{q(z)} \\
= \log p(x,z) - \log q(z) - \log \frac{p(z|x)}{q(z)} \\</script></li>
<li><p>两边对隐分布$q(z)$求期望</p>
<script type="math/tex; mode=display">
\log p(x) = \\
[ \int _z q(z) \log p(x,z)dz - \int _z q(z) \log q(z)dz ] + [- \int _z \log \frac{p(z|x)}{q(z)} q(z) dz ]\\
= ELBO+KL(q||p(z|x)) \\</script></li>
<li>我们希望推断隐变量$z$的后验分布$p(z|x)$，为此我们引入一个分布$q(z)$来近似这个后验。当目前观测量也就是对数似然确定的前提下，近似后验等价于使得$q(z)$和$p(z|x)$的KL散度最小，由上式可以看出，当ELBO最大时，KL散度最小。</li>
<li>接下来就是讨论如何使得ELBO最大化</li>
</ul>
<h2 id="任意分布上的变分推断"><a href="#任意分布上的变分推断" class="headerlink" title="任意分布上的变分推断"></a>任意分布上的变分推断</h2><ul>
<li>对任意分布使用，一次选取隐变量一个分量更新，比如第j个分量</li>
<li><p>我们自己选取的$q(z)$当然要比近似的分布简单，这里假设分布是独立的，隐变量是$M$维的：</p>
<script type="math/tex; mode=display">
q(z)=\prod _{i=1}^M q_i(z_i)</script></li>
<li><p>因此ELBO可以写成两部分</p>
<script type="math/tex; mode=display">
ELBO=\int \prod q_i(z_i) \log p(x,z) dz - \int \prod q_j(z_j) \sum \log q_j(z_j) dz \\
=part1-part2 \\</script></li>
<li><p>其中part1可以写成对隐变量各个维度求多重积分的形式，我们挑出第j个维度将其改写成</p>
<script type="math/tex; mode=display">
part1=\int \prod q_i(z_i) \log p(x,z) dz \\</script><script type="math/tex; mode=display">
= \int _{z_1} \int _{z_2} ... \int _{z_M} \prod _{i=1}^M q_i(z_i) \log p(x,z) d z_1 , d z_2 , ... ,d z_M \\</script><script type="math/tex; mode=display">
= \int _{z_j} q_j(z_j) ( \int _{z_{i \neq j}} \log (p(x,z)) \prod _{z_{i \neq j}} q_i(z_i) d z_i) d z_j \\</script><script type="math/tex; mode=display">
= \int _{z_j}  q_j(z_j) [E_{i \neq j} [\log (p(x,z))]] d z_j \\</script></li>
<li><p>在此我们定义一种伪分布的形式，一种分布的伪分布就是对其对数求积分再求指数：</p>
<script type="math/tex; mode=display">
p_j(z_j) = \int _{i \neq j} p(z_1,...,z_i) d z_1 , d z_2 ,..., d z_i \\</script><script type="math/tex; mode=display">
p_j^{'}(z_j) = exp \int _{i \neq j} \log p(z_1,...,z_i) d z_1 , d z_2 ,..., d z_i \\</script><script type="math/tex; mode=display">
\log p_j^{'}(z_j)  = \int _{i \neq j} \log p(z_1,...,z_i) d z_1 , d z_2 ,..., d z_i \\</script></li>
<li><p>这样part1用伪分布的形式可以改写成</p>
<script type="math/tex; mode=display">
part1= \int _{z_j} q_j(z_j) \log p_j^{'}(x,z_j) \\</script></li>
<li><p>part2中因为隐变量各个分量独立，可以把函数的和在联合分布上的期望改写成各个函数在边缘分布上的期望的和，在这些和中我们关注第j个变量，其余看成常量：</p>
<script type="math/tex; mode=display">
part2=\int \prod q_j(z_j) \sum \log q_j(z_j) dz \\</script><script type="math/tex; mode=display">
= \sum ( \int q_i(z_i) \log (q_i(z_i)) d z_i ) \\</script><script type="math/tex; mode=display">
= \int q_j(z_j) \log (q_j(z_j)) d z_j + const \\</script></li>
<li><p>再把part1和part2合起来，得到ELBO关于分量j的形式：</p>
<script type="math/tex; mode=display">
ELBO = \int _{z_j} \log \log p_j^{'}(x,z_j) -  \int q_j(z_j) \log (q_j(z_j)) d z_j + const \\</script><script type="math/tex; mode=display">
= \int _{z_j} q_j(z_j) \log \frac{p_j^{'}(x,z_j)}{q_j(z_j)} + const \\</script><script type="math/tex; mode=display">
= - KL(p_j^{'}(x,z_j) || q_j(z_j)) + const\\</script></li>
<li>也就是将ELBO写成了伪分布和近似分布之间的负KL散度，最大化ELBO就是最小化这个KL散度</li>
<li><p>何时这个KL散度最小？也就是：</p>
<script type="math/tex; mode=display">
q_j(z_j) = p_j^{'}(x,z_j) \\
\log q_j(z_j) = E_{i \neq j} [\log (p(x,z))] \\</script></li>
<li>到此我们就得到了变分推断下对于隐变量单一分量的近似分布迭代公式，在计算第j个分量的概率时，用到了$\log (p(x,z))$在其他所有分量$q_i(z_i)$上的期望，之后这个新的第j个分量的概率就参与下一次迭代，计算出其他分量的概率。</li>
</ul>
<h2 id="指数家族分布"><a href="#指数家族分布" class="headerlink" title="指数家族分布"></a>指数家族分布</h2><ul>
<li><p>定义指数家族分布：</p>
<script type="math/tex; mode=display">
p(x | \theta)=h(x) exp(\eta (\theta) \cdot T(x)-A(\theta)) \\</script></li>
<li>其中<ul>
<li>$T(x)$:sufficient statistics</li>
<li>$\theta$:parameter of the family</li>
<li>$\eta$:natural parameter</li>
<li>$h(x)$:underlying measure</li>
<li>$A(\theta)$:log normalizer / partition function</li>
</ul>
</li>
<li><p>注意parameter of the family和natural parameter都是向量，当指数家族分布处于标量化参数形式，即$\eta _i (\theta) = \theta _i$的时候，指数家族分布可以写成：</p>
<script type="math/tex; mode=display">
p(x | \eta)=h(x) exp(\eta (T(x) ^T \eta - A(\eta))</script></li>
<li><p>当我们把概率密度函数写成指数家族形式，求最大对数似然时，有：</p>
<script type="math/tex; mode=display">
\eta = \mathop{argmax} _ {\eta} [\log p(X | \eta)] \\</script><script type="math/tex; mode=display">
= \mathop{argmax} _ {\eta} [\log \prod p(x_i | \eta)] \\</script><script type="math/tex; mode=display">
= \mathop{argmax} _ {\eta} [\log [\prod h(x_i) exp [(\sum T(x_i))^T \eta - n A(\eta)]]] \\</script><script type="math/tex; mode=display">
= \mathop{argmax} _ {\eta} (\sum T(x_i))^T \eta - n A(\eta)] \\</script><script type="math/tex; mode=display">
= \mathop{argmax} _ {\eta} L(\eta) \\</script></li>
<li><p>继续求极值，我们就可以得到指数家族分布关于log normalizer和sufficient statistics的很重要的一个性质：</p>
<script type="math/tex; mode=display">
\frac{\partial L (\eta)}{\partial \eta} = \sum T(x_i) - n A^{'}(\eta) =0 \\</script><script type="math/tex; mode=display">
A^{'}(\eta) = \sum \frac{T(x_i)}{n} \\</script></li>
<li><p>举个例子，高斯分布写成指数家族分布形式：</p>
<script type="math/tex; mode=display">
p(x) = exp[- \frac{1}{2 \sigma ^2}x^2 + \frac{\mu}{\sigma ^2}x - \frac{\mu ^2}{2 \sigma ^2} - \frac 12 \log(2 \pi \sigma ^2)] \\</script><script type="math/tex; mode=display">
=exp ( [x \ x^2] [\frac{\mu}{\sigma ^2} \ \frac{-1}{2 \sigma ^2}] ^T - \frac{\mu ^2}{2 \sigma ^2} - \frac 12 \log(2 \pi \sigma ^2) )</script></li>
<li><p>用自然参数去替代方差和均值，写成指数家族分布形式：</p>
<script type="math/tex; mode=display">
p(x) = exp( [x \ x^2] [ \eta _1 \ \eta _2] ^T + \frac{\eta _1 ^2}{4 \eta _2} + \frac 12 \log (-2 \eta _2 ) - \frac 12 \log (2 \pi))</script></li>
<li>其中：<ul>
<li>$T(x)$:$[x \ x^2]$</li>
<li>$\eta$:$[ \eta _1 \ \eta _2] ^T$</li>
<li>$-A(\eta)$:$\frac{\eta _1 ^2}{4 \eta _2} + \frac 12 \log (-2 \eta _2 )$</li>
</ul>
</li>
<li><p>接下来我们利用指数家族的性质来快速计算均值和方差</p>
<script type="math/tex; mode=display">
A^{'}(\eta) = \sum \frac{T(x_i)}{n} \\</script><script type="math/tex; mode=display">
[\frac{\partial A}{\eta _1} \ \frac{\partial A}{\eta _2}] = [\frac{- \eta _1}{2 \eta _2} \ \frac{\eta _1 ^2 }{2 \eta _2}-\frac{1}{2 \eta _2}] \\</script><script type="math/tex; mode=display">
= [\frac{\sum x_i}{n} \ \frac{\sum x_i^2}{n}] \\</script><script type="math/tex; mode=display">
= [\mu \ \mu ^2 + \sigma ^2] \\</script></li>
<li><p>为什么$A(\eta)$叫做log normalizer？因为把概率密度的指数族分布积分有：</p>
<script type="math/tex; mode=display">
\int _x \frac{h(x)exp(T(x)^T \eta)}{exp(A(\eta))} = 1 \\</script><script type="math/tex; mode=display">
A(\eta) = \log \int _x h(x)exp(T(x)^T \eta) \\</script></li>
<li><p>下面讨论指数族分布的共轭关系，假设似然和先验均是指数族分布：</p>
<script type="math/tex; mode=display">
p(\beta | x) ∝ p(x | \beta) p(\beta) \\</script><script type="math/tex; mode=display">
∝ h(x) exp(T(x) \beta ^T - A_l (\beta)) h(\beta) exp(T(\beta) \alpha ^T - A(\alpha)) \\</script></li>
<li><p>用向量组的方式改写：</p>
<script type="math/tex; mode=display">
T(\beta) = [\beta \ -g(\beta)] \\</script><script type="math/tex; mode=display">
\alpha = [\alpha _1 \ \alpha _2] \\</script></li>
<li><p>原式中关于$\beta$，$h(x)$和$A(\alpha)$都是常数，从正比式中消去，带入向量组有：</p>
<script type="math/tex; mode=display">
∝ h(\beta) exp(T(x) \beta - A_l(\beta) + \alpha _1 \beta - \alpha _2 g(\beta)) \\</script></li>
<li><p>我们注意到，如果令$-g(\beta)=-A_l (\beta)$，原式就可以写成：</p>
<script type="math/tex; mode=display">
∝ h(\beta) exp((T(x)+\alpha _1)\beta - (1+\alpha _2) A_l (\beta)) \\</script><script type="math/tex; mode=display">
∝ h(\beta) exp(\alpha _1 ^{'} \beta - \alpha _2 ^{'} A_l (\beta)) \\</script></li>
<li>这样先验和后验形式一致，也就是共轭</li>
<li><p>这样我们用统一的形式写下似然和先验</p>
<script type="math/tex; mode=display">
p(\beta | x, \alpha) ∝ p(x | \beta) p(\beta | \alpha) \\</script><script type="math/tex; mode=display">
∝ h(x)exp[T(x)^T\beta - A_l(\beta)] h(\beta) exp[T(\beta)^T\alpha - A_l(\alpha)] \\</script></li>
<li><p>这里我们可以计算log normalizer关于参数求导的结果，注意，这是计算得到，不同于之前求指数族分布的最大似然估计得到的关于log normalizer和sufficient statistics的性质：</p>
<script type="math/tex; mode=display">
\frac{\partial A_l(\beta)}{\partial \beta}=\int _x T(x) p(x | \beta)dx \\</script><script type="math/tex; mode=display">
= E_{p(x|\beta)} [T(x)] \\</script></li>
<li>上式可以通过指数族分布积分为1，积分对$\beta$求导为0，将这个等式变换证明。</li>
</ul>
<h2 id="指数族分布下的变分推断"><a href="#指数族分布下的变分推断" class="headerlink" title="指数族分布下的变分推断"></a>指数族分布下的变分推断</h2><ul>
<li>接下来我们将ELBO中的参数后验写成指数族分布形式，可以看到最后的迭代公式相当简洁</li>
<li>我们假定要优化的参数有两个，x和z，我们用$\lambda$和$\phi$来近似$\eta(z,x)$和$\eta(\beta ,x)$，依然是要使ELBO最大，这时调整的参数是$q(\lambda , \phi)$，实际上是$\lambda$和$\phi$</li>
<li>我们采用固定一个参数，优化另一个参数的方法，相互迭代使得ELBO变大</li>
<li><p>首先我们改写ELBO，注意$q(z,\beta)=q(z)q(\beta)$：</p>
<script type="math/tex; mode=display">
ELBO=E_{q(z,\beta)}[\log p(x,z,\beta)] - E_{q(z,\beta)}[\log p(z,\beta)] \\</script><script type="math/tex; mode=display">
= E_{q(z,\beta)}[\log p(\beta | x,z) + \log p(z | x) + \log p(x)] - E_{q(z,\beta)}[\log q(\beta)] - E_{q(z,\beta)}[\log q(z)] \\</script></li>
<li><p>其中后验为指数家族分布，且q分布用简单的参数$\lambda$和$\phi$去近似：</p>
<script type="math/tex; mode=display">
p(\beta | x,z) = h(\beta) exp [ T(\beta) ^T \eta (z,x) - A_g (\eta(z,x))] \\</script><script type="math/tex; mode=display">
\approx q(\beta | \lambda) \\</script><script type="math/tex; mode=display">
= h(\beta) exp [ T(\beta) ^T \eta (\lambda - A_g (\eta(\lambda))] \\</script><script type="math/tex; mode=display">
p(z | x,\beta) = h(z) exp [ T(z) ^T \eta (\beta,x) - A_l (\eta(\beta,x))] \\</script><script type="math/tex; mode=display">
\approx q(\beta | \phi) \\</script><script type="math/tex; mode=display">
= h(z) exp [ T(z) ^T \eta (\phi - A_l (\eta(\phi))] \\</script></li>
<li><p>现在我们固定$\phi$，优化$\lambda$，将ELBO中无关常量除去，有：</p>
<script type="math/tex; mode=display">
ELBO_{\lambda} = E_{q(z,\beta)}[\log p(\beta | x,z)] - E_{q(z,\beta)}[\log q(\beta)] \\</script></li>
<li><p>代入指数家族分布，消去无关常量$- E_{q(z)}[A_g(\eta(x,z))]$，化简得到：</p>
<script type="math/tex; mode=display">
ELBO_{\lambda} = E_{q(\beta)}[T(\beta)^T] E_{q(z)}[\eta(z,x)]  -E_{q(\beta)} [T(\beta)^T \lambda] + A_g(\lambda)</script></li>
<li><p>利用之前log normalizer关于参数求导的结论，有:</p>
<script type="math/tex; mode=display">
ELBO_{\lambda} = A_g^{'}(\lambda)^T[E_{q(z)}[\eta(z,x)]] - \lambda A_g^{'}(\lambda) ^T + A_g (\lambda)</script></li>
<li><p>对上式求导，令其为0，有：</p>
<script type="math/tex; mode=display">
A_g^{''}(\lambda)^T[E_{q(z)}[\eta(z,x)]] - A_g^{'}(\lambda)-\lambda A_g^{''}(\lambda) ^T + A_g^{} (\lambda) = 0 \\
\lambda = E_{q(z)}[\eta(z,x)] \\</script></li>
<li><p>我们就得到了$\lambda$的迭代式！同理可以得到：</p>
<script type="math/tex; mode=display">
\phi = E_{q(\beta)}[\eta(\beta,x)] \\</script></li>
<li><p>写完整应该是：</p>
<script type="math/tex; mode=display">
\lambda = E_{q(z | \phi)}[\eta(z,x)] \\
\phi = E_{q(\beta | \lambda)}[\eta(\beta,x)] \\</script></li>
<li><p>观察这两个迭代式，变量更新的路径是:</p>
<script type="math/tex; mode=display">
\lambda \rightarrow q(\beta | \lambda) \rightarrow \phi \rightarrow q(z | \phi) \rightarrow \lambda</script></li>
</ul>
</div>
<script src="https://giscus.app/client.js"
        data-repo="thinkwee/thinkwee.github.io"
        data-repo-id="MDEwOlJlcG9zaXRvcnk3OTYxNjMwOA=="
        data-category="Announcements"
        data-category-id="DIC_kwDOBL7ZNM4CkozI"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="zh-CN"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/math/" rel="tag"># math</a>
              <a href="/tags/inference/" rel="tag"># inference</a>
              <a href="/tags/mcmc/" rel="tag"># mcmc</a>
              <a href="/tags/variational-inference/" rel="tag"># variational inference</a>
              <a href="/tags/em/" rel="tag"># em</a>
          </div>

        
  <div class="social-like a2a_kit a2a_kit_size_32 a2a_default_style">
    <a class="a2a_dd" target="_blank" rel="noopener" href="https://www.addtoany.com/share"></a>
      <a class="a2a_button_facebook"></a>
      <a class="a2a_button_twitter"></a>
  </div>

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/08/09/statistical-handwriting/" rel="prev" title="Statistical Learning - A hand-write note">
                  <i class="fa fa-angle-left"></i> Statistical Learning - A hand-write note
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/09/22/deepbayes2018/" rel="next" title="DeepBayes 2018">
                  DeepBayes 2018 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">ICP/IP地址/域名信息备案管理系统 </a>
      <img src="http://www.beian.gov.cn/img/new/gongan.png" alt=""><a href="https://beian.mps.gov.cn/#/query/webSearch?code=%E4%BA%ACICP%E5%A4%872023015408%E5%8F%B7" rel="noopener" target="_blank">京ICP备2023015408号 </a>
  </div>
  <div class="copyright">
    &copy; 2017 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Thinkwee</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">1m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">15:36</span>
  </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/thinkwee" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.3.0/pdfobject.min.js","integrity":"sha256-JJZNsid68vnh3/zyj0lY9BN5ynxVX/12XgOa1TlaYN0="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>





  <script src="/js/third-party/addtoany.js"></script>

  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"g58NgfMJBlwTyftr6hizdozq-gzGzoHsz","app_key":"1nA1tNVxeeSlAumHogP0PvSd","server_url":"https://leancloud.cn","security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"url":"https://thinkwee.top/2018/08/28/inference-algorithm/"}</script>
  <script src="/js/third-party/quicklink.js"></script>

</body>
</html>
